import { __rest, __assign } from 'tslib';
import React, { useState, useRef, useCallback, useEffect, useContext } from 'react';
import { Howl } from 'howler';

var noop = function noop() {};

var AudioPlayerContext =
/*#__PURE__*/
React.createContext(null);
function AudioPlayerProvider(_a) {
  var children = _a.children,
      value = _a.value;

  var _b = useState(null),
      player = _b[0],
      setPlayer = _b[1];

  var playerRef = useRef();

  var _c = useState(null),
      error = _c[0],
      setError = _c[1];

  var _d = useState(true),
      loading = _d[0],
      setLoading = _d[1];

  var _e = useState(false),
      playing = _e[0],
      setPlaying = _e[1];

  var _f = useState(true),
      stopped = _f[0],
      setStopped = _f[1];

  var load = useCallback(function (_a) {
    var src = _a.src,
        format = _a.format,
        _b = _a.autoplay,
        autoplay = _b === void 0 ? false : _b;
    var wasPlaying = false;

    if (playerRef.current) {
      // don't do anything if we're asked to reload the same source
      // @ts-ignore the _src argument actually exists
      if (playerRef.current._src === src) return;
      wasPlaying = playerRef.current.playing(); // destroys the previous player

      playerRef.current.unload();
    } // create a new player


    var howl = new Howl({
      src: src,
      format: format,
      autoplay: wasPlaying || autoplay,
      onload: function onload() {
        setError(null);
        setStopped(true);
        setLoading(false);
      },
      onplay: function onplay() {
        // prevents howl from playing the same song twice
        if (!howl.playing()) return;
        setPlaying(true);
        setStopped(false);
      },
      onend: function onend() {
        setStopped(true);
        setPlaying(false);
      },
      onpause: function onpause() {
        return void setPlaying(false);
      },
      onstop: function onstop() {
        setStopped(true);
        setPlaying(false);
      },
      onplayerror: function onplayerror(_id, error) {
        setError(new Error("[Play error] " + error));
        setPlaying(false);
        setStopped(true);
      },
      onloaderror: function onloaderror(_id, error) {
        setError(new Error("[Load error] " + error));
        setLoading(false);
      }
    });
    setPlayer(howl);
    playerRef.current = howl;
  }, []);
  useEffect(function () {
    // unload the player on unmount
    return function () {
      if (playerRef.current) playerRef.current.unload();
    };
  }, []);
  var contextValue = value ? value : {
    player: player,
    load: load,
    error: error,
    loading: loading,
    playing: playing,
    stopped: stopped,
    ready: !loading && !error
  };
  return React.createElement(AudioPlayerContext.Provider, {
    value: contextValue
  }, children);
}
var useAudioPlayer = function useAudioPlayer(props) {
  var _a = useContext(AudioPlayerContext),
      player = _a.player,
      load = _a.load,
      context = __rest(_a, ["player", "load"]);

  var _b = props || {},
      src = _b.src,
      format = _b.format,
      autoplay = _b.autoplay;

  useEffect(function () {
    // if useAudioPlayer is called without arguments
    // don't do anything: the user will have access
    // to the current context
    if (!src) return;
    load({
      src: src,
      format: format,
      autoplay: autoplay
    });
  }, [src, format, autoplay, load]);
  return __assign(__assign({}, context), {
    play: player ? player.play.bind(player) : noop,
    pause: player ? player.pause.bind(player) : noop,
    stop: player ? player.stop.bind(player) : noop,
    mute: player ? player.mute.bind(player) : noop,
    seek: player ? player.seek.bind(player) : noop,
    load: load
  });
}; // gives current audio position state - updates in an animation frame loop for animating audio visualizations

var useAudioPosition = function useAudioPosition() {
  var _a = useContext(AudioPlayerContext),
      player = _a.player,
      playing = _a.playing,
      stopped = _a.stopped;

  var _b = useState(0),
      position = _b[0],
      setPosition = _b[1];

  var _c = useState(0),
      duration = _c[0],
      setDuration = _c[1]; // sets position and duration on player initialization and when the audio is stopped


  useEffect(function () {
    if (player) {
      setPosition(player.seek());
      setDuration(player.duration());
    }
  }, [player, stopped]); // updates position on a one second loop

  useEffect(function () {
    var timeout;
    if (player && playing) timeout = window.setInterval(function () {
      return setPosition(player.seek());
    }, 1000);
    return function () {
      return clearTimeout(timeout);
    };
  }, [player, playing]);
  return {
    position: position,
    duration: duration
  };
};

export { AudioPlayerProvider, useAudioPlayer, useAudioPosition };
//# sourceMappingURL=react-use-audio-player.esm.js.map
