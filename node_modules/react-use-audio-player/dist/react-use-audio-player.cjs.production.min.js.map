{"version":3,"file":"react-use-audio-player.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React, {\n    useState,\n    useCallback,\n    useEffect,\n    useRef,\n    useContext\n} from \"react\"\nimport { Howl } from \"howler\"\n\nconst noop = () => {}\n\ninterface AudioSrcProps {\n    src: string\n    format?: string\n    autoplay?: boolean\n}\n\ninterface AudioPlayer {\n    player: Howl | null\n    load: (args: AudioSrcProps) => void\n    error: Error | null\n    loading: boolean\n    playing: boolean\n    stopped: boolean\n    ready: boolean\n}\n\ntype UseAudioPlayer = Omit<AudioPlayer, \"player\"> & {\n    play: Howl[\"play\"] | typeof noop\n    pause: Howl[\"pause\"] | typeof noop\n    stop: Howl[\"stop\"] | typeof noop\n    mute: Howl[\"mute\"] | typeof noop\n    seek: Howl[\"seek\"] | typeof noop\n}\n\nconst AudioPlayerContext = React.createContext<AudioPlayer | null>(null)\n\ninterface AudioPlayerProviderProps {\n    children: React.ReactNode\n    value?: AudioPlayer\n}\n\ninterface AudioPosition {\n    position: number\n    duration: number\n}\n\nexport function AudioPlayerProvider({\n    children,\n    value\n}: AudioPlayerProviderProps) {\n    const [player, setPlayer] = useState<Howl | null>(null)\n    const playerRef = useRef<Howl>()\n    const [error, setError] = useState<Error | null>(null)\n    const [loading, setLoading] = useState(true)\n    const [playing, setPlaying] = useState(false)\n    const [stopped, setStopped] = useState(true)\n\n    const load = useCallback(\n        ({ src, format, autoplay = false }: AudioSrcProps) => {\n            let wasPlaying = false\n            if (playerRef.current) {\n                // don't do anything if we're asked to reload the same source\n                // @ts-ignore the _src argument actually exists\n                if (playerRef.current._src === src) return\n                wasPlaying = playerRef.current.playing()\n                // destroys the previous player\n                playerRef.current.unload()\n            }\n\n            // create a new player\n            const howl = new Howl({\n                src,\n                format,\n                autoplay: wasPlaying || autoplay, // continues playing next song\n                onload: () => {\n                    setError(null)\n                    setStopped(true)\n                    setLoading(false)\n                },\n                onplay: () => {\n                    // prevents howl from playing the same song twice\n                    if (!howl.playing()) return\n                    setPlaying(true)\n                    setStopped(false)\n                },\n                onend: () => {\n                    setStopped(true)\n                    setPlaying(false)\n                },\n                onpause: () => void setPlaying(false),\n                onstop: () => {\n                    setStopped(true)\n                    setPlaying(false)\n                },\n                onplayerror: (_id, error) => {\n                    setError(new Error(\"[Play error] \" + error))\n                    setPlaying(false)\n                    setStopped(true)\n                },\n                onloaderror: (_id, error) => {\n                    setError(new Error(\"[Load error] \" + error))\n                    setLoading(false)\n                }\n            })\n\n            setPlayer(howl)\n            playerRef.current = howl\n        },\n        []\n    )\n\n    useEffect(() => {\n        // unload the player on unmount\n        return () => {\n            if (playerRef.current) playerRef.current.unload()\n        }\n    }, [])\n\n    const contextValue: AudioPlayer = value\n        ? value\n        : {\n              player,\n              load,\n              error,\n              loading,\n              playing,\n              stopped,\n              ready: !loading && !error\n          }\n\n    return (\n        <AudioPlayerContext.Provider value={contextValue}>\n            {children}\n        </AudioPlayerContext.Provider>\n    )\n}\n\nexport const useAudioPlayer = (props?: AudioSrcProps): UseAudioPlayer => {\n    const { player, load, ...context } = useContext(AudioPlayerContext)!\n\n    const { src, format, autoplay } = props || {}\n\n    useEffect(() => {\n        // if useAudioPlayer is called without arguments\n        // don't do anything: the user will have access\n        // to the current context\n        if (!src) return\n        load({ src, format, autoplay })\n    }, [src, format, autoplay, load])\n\n    return {\n        ...context,\n        play: player ? player.play.bind(player) : noop,\n        pause: player ? player.pause.bind(player) : noop,\n        stop: player ? player.stop.bind(player) : noop,\n        mute: player ? player.mute.bind(player) : noop,\n        seek: player ? player.seek.bind(player) : noop,\n        load\n    }\n}\n\n// gives current audio position state - updates in an animation frame loop for animating audio visualizations\nexport const useAudioPosition = (): AudioPosition => {\n    const { player, playing, stopped } = useContext(AudioPlayerContext)!\n\n    const [position, setPosition] = useState(0)\n    const [duration, setDuration] = useState(0)\n\n    // sets position and duration on player initialization and when the audio is stopped\n    useEffect(() => {\n        if (player) {\n            setPosition(player.seek() as number)\n            setDuration(player.duration() as number)\n        }\n    }, [player, stopped])\n\n    // updates position on a one second loop\n    useEffect(() => {\n        let timeout: number\n        if (player && playing)\n            timeout = window.setInterval(\n                () => setPosition(player.seek() as number),\n                1000\n            )\n        return () => clearTimeout(timeout)\n    }, [player, playing])\n\n    return { position, duration }\n}\n"],"names":["noop","AudioPlayerContext","React","createContext","_a","children","value","_b","player","setPlayer","playerRef","useRef","_c","error","setError","_d","loading","setLoading","_e","playing","setPlaying","_f","stopped","setStopped","load","useCallback","src","format","autoplay","wasPlaying","current","_src","unload","howl","Howl","onload","onplay","onend","onpause","onstop","onplayerror","_id","Error","onloaderror","useEffect","Provider","ready","props","context","play","bind","pause","stop","mute","seek","position","setPosition","duration","setDuration","timeout","window","setInterval","clearTimeout"],"mappings":"2LASMA,EAAO,aA0BPC,EAAqBC,EAAMC,cAAkC,2CAY/BC,OAChCC,aACAC,UAEMC,mBAACC,OAAQC,OACTC,EAAYC,WACZC,mBAACC,OAAOC,OACRC,iBAACC,OAASC,OACVC,iBAACC,OAASC,OACVC,iBAACC,OAASC,OAEVC,EAAOC,eACT,SAACrB,OAAEsB,QAAKC,WAAQpB,aAAAqB,gBACRC,GAAa,KACbnB,EAAUoB,QAAS,IAGfpB,EAAUoB,QAAQC,OAASL,EAAK,OACpCG,EAAanB,EAAUoB,QAAQX,UAE/BT,EAAUoB,QAAQE,aAIhBC,EAAO,IAAIC,OAAK,CAClBR,MACAC,SACAC,SAAUC,GAAcD,EACxBO,OAAQ,WACJrB,EAAS,MACTS,GAAW,GACXN,GAAW,IAEfmB,OAAQ,WAECH,EAAKd,YACVC,GAAW,GACXG,GAAW,KAEfc,MAAO,WACHd,GAAW,GACXH,GAAW,IAEfkB,QAAS,WAAWlB,GAAW,IAC/BmB,OAAQ,WACJhB,GAAW,GACXH,GAAW,IAEfoB,YAAa,SAACC,EAAK5B,GACfC,EAAS,IAAI4B,MAAM,gBAAkB7B,IACrCO,GAAW,GACXG,GAAW,IAEfoB,YAAa,SAACF,EAAK5B,GACfC,EAAS,IAAI4B,MAAM,gBAAkB7B,IACrCI,GAAW,MAInBR,EAAUwB,GACVvB,EAAUoB,QAAUG,IAExB,WAGJW,aAAU,kBAEC,WACClC,EAAUoB,SAASpB,EAAUoB,QAAQE,YAE9C,IAeC9B,gBAACD,EAAmB4C,UAASvC,MAbCA,GAE5B,CACIE,SACAgB,OACAX,QACAG,UACAG,UACAG,UACAwB,OAAQ9B,IAAYH,IAKrBR,2BAKiB,SAAC0C,OACrB3C,kBAAEI,WAAQgB,SAAMwB,gCAEhBzC,QAAEmB,QAAKC,WAAQC,oBAErBgB,aAAU,WAIDlB,GACLF,EAAK,CAAEE,MAAKC,SAAQC,eACrB,CAACF,EAAKC,EAAQC,EAAUJ,6BAGpBwB,IACHC,KAAMzC,EAASA,EAAOyC,KAAKC,KAAK1C,GAAUR,EAC1CmD,MAAO3C,EAASA,EAAO2C,MAAMD,KAAK1C,GAAUR,EAC5CoD,KAAM5C,EAASA,EAAO4C,KAAKF,KAAK1C,GAAUR,EAC1CqD,KAAM7C,EAASA,EAAO6C,KAAKH,KAAK1C,GAAUR,EAC1CsD,KAAM9C,EAASA,EAAO8C,KAAKJ,KAAK1C,GAAUR,EAC1CwB,mCAKwB,eACtBpB,kBAAEI,WAAQW,YAASG,YAEnBf,gBAACgD,OAAUC,OACX5C,gBAAC6C,OAAUC,cAGjBd,aAAU,WACFpC,IACAgD,EAAYhD,EAAO8C,QACnBI,EAAYlD,EAAOiD,eAExB,CAACjD,EAAQc,IAGZsB,aAAU,eACFe,SACAnD,GAAUW,IACVwC,EAAUC,OAAOC,aACb,kBAAML,EAAYhD,EAAO8C,UACzB,MAED,kBAAMQ,aAAaH,MAC3B,CAACnD,EAAQW,IAEL,CAAEoC,WAAUE"}