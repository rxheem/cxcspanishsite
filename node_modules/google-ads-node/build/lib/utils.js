"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const protobufHelpers = __importStar(require("google-protobuf/google/protobuf/field_mask_pb"));
const lodash_camelcase_1 = __importDefault(require("lodash.camelcase"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_set_1 = __importDefault(require("lodash.set"));
const lodash_snakecase_1 = __importDefault(require("lodash.snakecase"));
const structs = __importStar(require("./struct"));
const NON_MUTABLE_METHOD_PREFIXES = ["Get", "List", "Generate", "Search"];
// Based on https://github.com/leaves4j/grpc-promisify/blob/master/src/index.js
function promisifyServiceClient(client) {
    Object.keys(Object.getPrototypeOf(client)).forEach((functionName) => {
        if (functionName.charAt(0) === "$" || functionName.charAt(0) === "_") {
            return;
        }
        const originalFunction = client[functionName];
        client[functionName] = (request, callback) => {
            if (callback && typeof callback === "function") {
                return originalFunction.call(client, request, (error, response) => {
                    callback(error, response);
                });
            }
            return new Promise((resolve, reject) => {
                originalFunction.call(client, request, (error, response) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(response);
                    }
                });
            });
        };
    });
}
exports.promisifyServiceClient = promisifyServiceClient;
function formatCallResults(resultsList, fieldMask) {
    const parsedResults = [];
    if (fieldMask) {
        const { pathsList } = fieldMask;
        for (const result of resultsList) {
            const parsedRow = parseNestedEntities(result, pathsList);
            parsedResults.push(parsedRow);
        }
    }
    else {
        for (const result of resultsList) {
            const parsedRow = parseNestedEntitiesNoPath(result);
            parsedResults.push(parsedRow);
        }
    }
    return parsedResults;
}
exports.formatCallResults = formatCallResults;
function convertToProtoFormat(data, type, resource_name, nested_path = "") {
    const pb = {};
    const struct = structs[resource_name];
    if (!struct) {
        throw new Error(`Key "${nested_path.replace(".", "")}" not found in resource "${resource_name}"`);
    }
    for (const key of Object.keys(data)) {
        const displayKey = lodash_camelcase_1.default(key);
        const value = data[key];
        /* Resource names are string values, not a protobuf string instance, so just set the string value */
        if (displayKey === "resourceName") {
            pb[displayKey] = value;
            continue;
        }
        /* Build array of proto values */
        if (Array.isArray(value)) {
            pb[displayKey] = value.map((v) => {
                return unroll(v);
            });
            continue;
        }
        pb[displayKey] = unroll(value);
        function unroll(v) {
            return typeof v === "object"
                ? convertToProtoFormat(v, type, resource_name, `${nested_path}.${key}`)
                : toProtoValueFormat(v, struct, `${nested_path}.${key}`.replace(".", ""));
        }
    }
    return pb;
}
exports.convertToProtoFormat = convertToProtoFormat;
function toProtoValueFormat(value, struct, nested_path) {
    const valueType = lodash_get_1.default(struct, nested_path);
    if (!valueType) {
        throw new Error(`Attempted to set value "${value}" on invalid path "${nested_path}" in resource`);
    }
    if (valueType.startsWith("enum_")) {
        return value;
    }
    return {
        value,
    };
}
/* This is different to lodash.camelCase as it leaves any periods (".") */
function convertPathToCamelCase(str) {
    return str.replace(/([-_][a-z])/gi, $1 => {
        return $1
            .toUpperCase()
            .replace("-", "")
            .replace("_", "");
    });
}
function parseNestedEntitiesNoPath(data, _structs = structs) {
    if (typeof data === "string" || typeof data === "number" || typeof data === "boolean") {
        return data;
    }
    const findMatchingStruct = (key) => {
        const capitalcase_key = key.charAt(0).toUpperCase() + key.slice(1);
        const snakecase_key = lodash_snakecase_1.default(key);
        // We need both cases because the structs.ts file exports resources in CapitalCase,
        // but the keys inside each resource are in snake_case. parseNestedEntitiesNoPath() is
        // recursive, so we're not sure which one we'll need.
        // @ts-ignore
        return _structs[capitalcase_key] || _structs[snakecase_key];
    };
    const finalObject = {};
    Object.keys(data).map(key => {
        let displayKey = key;
        /*
          This section regarding "matching structs" is designed to correctly
          trim keys that end in "List". Some of those keys are legit (such as userList)
          while others are bogus (such as pointsList). The bogus ones need trimming so
          that the final result returned to the user matches the format specified in the docs.
    
          This adds other layer of recusive complexity to this function, and I'm open to improvements.
        */
        let matching_struct = findMatchingStruct(displayKey);
        if (!matching_struct && key.endsWith("List")) {
            // Trim "List" only if bogus key
            displayKey = key.split("List")[0];
            matching_struct = findMatchingStruct(displayKey);
        }
        const entity = data[key];
        const isObject = typeof entity === "object";
        const isUndefined = typeof entity === "undefined";
        const isArray = Array.isArray(entity);
        // It needs its "value" unwrapped if it is an object and has "value" as its only key.
        const isValue = isObject
            ? entity.hasOwnProperty("value") && Object.keys(entity).length === 1
            : false;
        if (isUndefined) {
            return;
        }
        if (isArray) {
            finalObject[displayKey] = entity.map((item) => {
                // @ts-ignore
                const parsed = parseNestedEntitiesNoPath({ item }, { item: matching_struct });
                return parsed.item;
            });
        }
        else if (isValue) {
            finalObject[displayKey] = entity.value;
        }
        else if (isObject) {
            finalObject[displayKey] = parseNestedEntitiesNoPath(entity, matching_struct);
        }
        else {
            finalObject[displayKey] = entity;
        }
    });
    return finalObject;
}
// This function first parses the data without regard for the passed props,
// then plucks out the props that it actually cares about.
function parseNestedEntities(data, props) {
    const parsed_data = parseNestedEntitiesNoPath(data);
    const final_object = {};
    for (let path of props) {
        path = convertPathToCamelCase(path);
        // Pluck resource name if available
        const path_elements_trimmed = path.split(".");
        while (path_elements_trimmed.pop()) {
            path_elements_trimmed.push("resourceName");
            const rn_path = path_elements_trimmed.join(".");
            path_elements_trimmed.pop();
            if (lodash_get_1.default(parsed_data, rn_path)) {
                lodash_set_1.default(final_object, rn_path, lodash_get_1.default(parsed_data, rn_path));
            }
        }
        // And pluck the field specified in path
        const plucked_value = lodash_get_1.default(parsed_data, path);
        if (typeof plucked_value !== "undefined") {
            lodash_set_1.default(final_object, path, plucked_value);
        }
    }
    return final_object;
}
function recursiveFieldMaskSearch(data) {
    const paths = [];
    for (const key of Object.keys(data)) {
        if (key === "resource_name") {
            continue;
        }
        const value = data[key];
        if (typeof value === "object" && !Array.isArray(value)) {
            const children = recursiveFieldMaskSearch(value);
            for (const child of children) {
                paths.push(`${key}.${child}`);
            }
            continue;
        }
        paths.push(key);
    }
    return paths;
}
function getFieldMask(data) {
    const fieldMask = new protobufHelpers.FieldMask();
    const paths = recursiveFieldMaskSearch(data);
    fieldMask.setPathsList(paths);
    return fieldMask;
}
exports.getFieldMask = getFieldMask;
function getErrorLocationPath(location) {
    if (!location || !location.hasOwnProperty("fieldPathElementsList")) {
        return "";
    }
    if (!Array.isArray(location.fieldPathElementsList) && location.fieldPathElementsList.length < 1) {
        return "";
    }
    const { fieldPathElementsList } = location;
    const paths = fieldPathElementsList.map((field) => {
        let path = field.fieldName;
        if (field.index && field.index.hasOwnProperty("value")) {
            path += `[${field.index.value}]`;
        }
        return path;
    });
    return paths.join(".");
}
exports.getErrorLocationPath = getErrorLocationPath;
function isMutationRequest(interceptMessage) {
    var _a, _b;
    let isMutation = true;
    if ((_b = (_a = interceptMessage) === null || _a === void 0 ? void 0 : _a.method_definition) === null || _b === void 0 ? void 0 : _b.path) {
        const { path } = interceptMessage.method_definition;
        for (const prefix of NON_MUTABLE_METHOD_PREFIXES) {
            if (path.includes(prefix)) {
                isMutation = false;
                break;
            }
        }
    }
    return isMutation;
}
exports.isMutationRequest = isMutationRequest;
function safeguardMutationProtobufRequest(message, next) {
    var _a, _b, _c;
    // Force validation only for requests if the setValidateOnly method exists
    if ((_a = message) === null || _a === void 0 ? void 0 : _a.setValidateOnly) {
        message.setValidateOnly(true);
        next(message);
        // If the request doesn't support validateOnly, we attempt to clear the operations list
    }
    else if ((_b = message) === null || _b === void 0 ? void 0 : _b.clearOperationsList) {
        message.clearOperationsList();
        next(message);
        // Some request operations are called mutate_operations
    }
    else if ((_c = message) === null || _c === void 0 ? void 0 : _c.clearMutateOperationsList) {
        message.clearMutateOperationsList();
        next(message);
    }
    else {
        // Otherwise, we just give up to prevent any unwanted mutations (this throws an error, shouldn't happen)
        throw new Error(`Prevent mutations mode is enabled, but the request couldn't be safeguarded, giving up.`);
    }
}
exports.safeguardMutationProtobufRequest = safeguardMutationProtobufRequest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLCtGQUFpRjtBQUVqRix3RUFBeUM7QUFDekMsNERBQTZCO0FBQzdCLDREQUE2QjtBQUM3Qix3RUFBeUM7QUFFekMsa0RBQW9DO0FBRXBDLE1BQU0sMkJBQTJCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztBQUUxRSwrRUFBK0U7QUFDL0UsU0FBZ0Isc0JBQXNCLENBQUMsTUFBYztJQUNuRCxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFvQixFQUFFLEVBQUU7UUFDMUUsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRTtZQUNwRSxPQUFPO1NBQ1I7UUFDRCxNQUFNLGdCQUFnQixHQUFJLE1BQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUV0RCxNQUFjLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFZLEVBQUUsUUFBYSxFQUFFLEVBQUU7WUFDOUQsSUFBSSxRQUFRLElBQUksT0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFO2dCQUM5QyxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBVSxFQUFFLFFBQWEsRUFBRSxFQUFFO29CQUMxRSxRQUFRLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUM1QixDQUFDLENBQUMsQ0FBQzthQUNKO1lBRUQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtnQkFDckMsZ0JBQWdC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