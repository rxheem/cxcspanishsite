var _class, _temp2;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';

var _default = (_temp2 = _class = function (_Component) {
  _inherits(_default, _Component);

  function _default() {
    var _temp, _this, _ret;

    _classCallCheck(this, _default);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.prevScroll = 0, _this.handleScrollerRef = function (reference) {
      _this.scroller = reference;
    }, _this.handleHorizontalScroll = function () {
      var _this$scroller = _this.scroller,
          firstChild = _this$scroller.firstChild,
          lastChild = _this$scroller.lastChild,
          scrollLeft = _this$scroller.scrollLeft,
          offsetLeft = _this$scroller.offsetLeft,
          offsetWidth = _this$scroller.offsetWidth;
      var _this$props = _this.props,
          onReachRight = _this$props.onReachRight,
          onReachLeft = _this$props.onReachLeft;


      var leftEdge = firstChild.offsetLeft;
      var rightEdge = lastChild.offsetLeft + lastChild.offsetWidth;
      var scrolledLeft = scrollLeft + offsetLeft;
      var scrolledRight = scrolledLeft + offsetWidth;

      if (scrolledRight >= rightEdge) {
        onReachRight();
      } else if (scrolledLeft <= leftEdge) {
        onReachLeft();
      }
    }, _this.handleVerticalScroll = function () {
      var _this$scroller2 = _this.scroller,
          firstChild = _this$scroller2.firstChild,
          lastChild = _this$scroller2.lastChild,
          scrollTop = _this$scroller2.scrollTop,
          offsetTop = _this$scroller2.offsetTop,
          offsetHeight = _this$scroller2.offsetHeight;
      var _this$props2 = _this.props,
          onReachTop = _this$props2.onReachTop,
          onReachBottom = _this$props2.onReachBottom;


      var topEdge = firstChild.offsetTop;
      var bottomEdge = lastChild.offsetTop + lastChild.offsetHeight;
      var scrolledUp = scrollTop + offsetTop;
      var scrolledDown = scrolledUp + offsetHeight;

      if (scrolledDown >= bottomEdge) {
        onReachBottom();
      } else if (scrolledUp <= topEdge) {
        onReachTop();
      }
    }, _this.handleScroll = function () {
      var _this$props3 = _this.props,
          horizontal = _this$props3.horizontal,
          onScroll = _this$props3.onScroll;


      var scrolledTo = 0;

      if (horizontal) {
        _this.handleHorizontalScroll();
        scrolledTo = _this.scroller.scrollLeft;
      } else {
        _this.handleVerticalScroll();
        scrolledTo = _this.scroller.scrollTop;
      }

      onScroll(scrolledTo, _this.prevScroll);
      _this.prevScroll = scrolledTo;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _default.prototype.componentDidMount = function componentDidMount() {
    var position = this.props.position;


    if (position) {
      this.setScrollPosition(position);
    }
  };

  _default.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var position = this.props.position;


    if (position !== prevProps.position) {
      this.setScrollPosition(position);
    }
  };

  _default.prototype.setScrollPosition = function setScrollPosition() {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (this.props.horizontal) {
      this.scroller.scrollLeft = position;
    } else {
      this.scroller.scrollTop = position;
    }

    this.prevScroll = position;
  };

  _default.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        horizontal = _props.horizontal;


    var whiteSpace = horizontal ? 'nowrap' : 'normal';

    return React.createElement(
      'div',
      {
        ref: this.handleScrollerRef,
        style: {
          overflow: 'auto',
          height: 'inherit',
          width: 'inherit',
          WebkitOverflowScrolling: 'inherit',
          whiteSpace: whiteSpace
        },
        onScroll: this.handleScroll },
      children
    );
  };

  return _default;
}(Component), _class.propTypes = {
  children: PropTypes.node.isRequired,
  horizontal: PropTypes.bool,
  onReachBottom: PropTypes.func,
  onReachTop: PropTypes.func,
  onReachLeft: PropTypes.func,
  onReachRight: PropTypes.func,
  onScroll: PropTypes.func,
  position: PropTypes.number
}, _class.defaultProps = {
  horizontal: false,
  onReachBottom: function onReachBottom(f) {
    return f;
  },
  onReachTop: function onReachTop(f) {
    return f;
  },
  onReachLeft: function onReachLeft(f) {
    return f;
  },
  onReachRight: function onReachRight(f) {
    return f;
  },
  onScroll: function onScroll(f) {
    return f;
  },
  position: 0
}, _temp2);

export { _default as default };