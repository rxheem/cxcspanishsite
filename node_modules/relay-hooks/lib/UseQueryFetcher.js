"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReactRelayQueryFetcher = require("react-relay/lib/ReactRelayQueryFetcher");
var relay_runtime_1 = require("relay-runtime");
var Utils_1 = require("./Utils");
var UseQueryFetcher = /** @class */ (function () {
    function UseQueryFetcher(forceUpdate) {
        this._queryFetcher = new ReactRelayQueryFetcher();
        this._forceUpdate = forceUpdate;
    }
    UseQueryFetcher.prototype.getLastResult = function () {
        return this._lastResult;
    };
    UseQueryFetcher.prototype.dispose = function () {
        this._queryFetcher.dispose();
    };
    UseQueryFetcher.prototype.lookupInStore = function (environment, operation, fetchPolicy) {
        if (Utils_1.isStorePolicy(fetchPolicy) && environment.check(operation.root)) {
            this._queryFetcher._retainCachedOperation(environment, operation);
            return environment.lookup(operation.fragment, operation);
        }
        return null;
    };
    UseQueryFetcher.prototype.execute = function (environment, query, variables, fetchPolicy, cacheConfig) {
        var renderProps = this._execute(environment, query, variables, fetchPolicy, cacheConfig);
        this._lastResult = renderProps;
    };
    UseQueryFetcher.prototype._execute = function (environment, query, variables, fetchPolicy, cacheConfig) {
        var _this = this;
        if (!query) {
            this._queryFetcher.dispose();
            return this.getResult(environment, query, variables, fetchPolicy, cacheConfig, { empty: true });
        }
        this._queryFetcher.disposeRequest();
        var request = relay_runtime_1.getRequest(query);
        var operation = relay_runtime_1.createOperationDescriptor(request, variables);
        try {
            var storeSnapshot = this.lookupInStore(environment, operation, fetchPolicy);
            var isNetwork = Utils_1.isNetworkPolicy(fetchPolicy, storeSnapshot);
            if (isNetwork) {
                this._queryFetcher._fetchOptions = null;
            }
            var querySnapshot = isNetwork ? this._queryFetcher.fetch({
                cacheConfig: cacheConfig,
                environment: environment,
                onDataChange: function (params) {
                    var error = params.error == null ? null : params.error;
                    var snapshot = params.snapshot == null ? null : params.snapshot;
                    var onDataChangeProps = _this.getResult(environment, query, variables, fetchPolicy, cacheConfig, { error: error, snapshot: snapshot, cached: false });
                    if (_this._lastResult !== onDataChangeProps) {
                        _this._lastResult = onDataChangeProps;
                        _this._forceUpdate(onDataChangeProps);
                    }
                },
                operation: operation,
            }) : null;
            // Use network data first, since it may be fresher
            var snapshot = querySnapshot || storeSnapshot;
            return this.getResult(environment, query, variables, fetchPolicy, cacheConfig, { error: null, snapshot: snapshot, cached: !!storeSnapshot }); //relay
        }
        catch (error) {
            return this.getResult(environment, query, variables, fetchPolicy, cacheConfig, { error: error, snapshot: null, cached: false }); //relay
        }
    };
    UseQueryFetcher.prototype.getResult = function (environment, query, variables, fetchPolicy, cacheConfig, result) {
        var _this = this;
        if (!result) {
            return;
        }
        var renderProps = {
            error: null,
            props: result.empty ? {} : null,
            retry: null,
            cached: false
        };
        if (result.snapshot || result.error || result.cached) {
            renderProps.props = result.snapshot ? result.snapshot.data : null;
            renderProps.error = result.error ? result.error : null;
            renderProps.cached = result.cached || false;
            renderProps.retry = function (cacheConfigOverride) {
                if (cacheConfigOverride === void 0) { cacheConfigOverride = cacheConfig; }
                var retryProps = _this._execute(environment, query, variables, fetchPolicy, cacheConfigOverride);
                if (_this._lastResult !== retryProps) {
                    _this._lastResult = retryProps;
                    _this._forceUpdate(retryProps);
                }
            };
        }
        return renderProps;
    };
    return UseQueryFetcher;
}());
exports.default = UseQueryFetcher;
