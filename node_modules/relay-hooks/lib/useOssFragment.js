"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var areEqual = require("fbjs/lib/areEqual");
var relay_runtime_1 = require("relay-runtime");
var react_relay_1 = require("react-relay");
var relay_runtime_2 = require("relay-runtime");
var FragmentRefetch_1 = require("./FragmentRefetch");
var FragmentPagination_1 = require("./FragmentPagination");
;
var usePrevious = function usePrevious(value) {
    var ref = react_1.useRef();
    if (ref.current === null || ref.current === undefined) {
        var c = {
            fragmentRefetch: new FragmentRefetch_1.default(),
            fragmentPagination: new FragmentPagination_1.default()
        };
        ref.current = c;
    }
    react_1.useEffect(function () {
        value.fragmentRefetch = ref.current.fragmentRefetch;
        value.fragmentPagination = ref.current.fragmentPagination;
        ref.current = value;
    });
    return ref.current;
};
var useOssFragment = function (fragmentDef, fragmentRef) {
    var environment = react_1.useContext(react_relay_1.ReactRelayContext).environment;
    var prev = usePrevious({ environment: environment, fragmentRef: fragmentRef });
    var propsFragments = { frag: fragmentRef };
    var _a = react_1.useState(function () {
        relay_runtime_1.RelayFeatureFlags.PREFER_FRAGMENT_OWNER_OVER_CONTEXT = true;
        return relay_runtime_1.getFragment(fragmentDef);
    }), fragments = _a[0], setFragments = _a[1];
    var ref = react_1.useRef(null);
    var _b = react_1.useState(function () {
        return newResolver();
    }), result = _b[0], setResult = _b[1];
    var resolver = result.resolver;
    ref.current = resolver;
    function newResolver() {
        var res = relay_runtime_1.createFragmentSpecResolver({ environment: environment }, 'useFragment', { frag: fragments }, propsFragments);
        res.setCallback(function () {
            var newData = res.resolve();
            if (result.data !== newData) {
                setResult({ resolver: res, data: newData });
            }
        });
        return { resolver: res, data: res.resolve() };
    }
    react_1.useEffect(function () {
        return function () {
            ref.current.dispose();
            prev && prev.fragmentRefetch.dispose();
            prev && prev.fragmentPagination.dispose();
        };
    }, []);
    react_1.useEffect(function () {
        if (prev && prev.fragmentRef) {
            var prevIDs = relay_runtime_1.getDataIDsFromFragment(fragments, prev.fragmentRef);
            var nextIDs = relay_runtime_1.getDataIDsFromFragment(fragments, fragmentRef);
            if (prev.environment !== environment ||
                _getFragmentVariables() !== _getFragmentVariables(prev.fragmentRef) ||
                !areEqual(prevIDs, nextIDs)) {
                resolver.dispose();
                setResult(newResolver());
            }
        }
    }, [environment, fragmentRef]);
    function _getFragmentVariables(fRef) {
        if (fRef === void 0) { fRef = fragmentRef; }
        // hack v6.0.0
        if (relay_runtime_1.getVariablesFromFragment.length === 2) {
            return relay_runtime_1.getVariablesFromFragment(fragments, fRef);
        }
        return relay_runtime_1.getVariablesFromFragment(
        // NOTE: We pass empty operationVariables because we want to prefer
        // the variables from the fragment owner
        {}, fragments, fRef, relay_runtime_2.getFragmentOwner(fragments, fRef));
    }
    function refetch(taggedNode, refetchVariables, renderVariables, observerOrCallback, options) {
        return prev.fragmentRefetch.refetch(environment, _getFragmentVariables(), taggedNode, refetchVariables, renderVariables, observerOrCallback, options, result, setResult);
    }
    function loadMore(connectionConfig, pageSize, observerOrCallback, options) {
        return prev.fragmentPagination.loadMore(environment, connectionConfig, propsFragments, pageSize, observerOrCallback, options, result, setResult);
    }
    function refetchConnection(connectionConfig, totalCount, callback, refetchVariables) {
        return prev.fragmentPagination.refetchConnection(environment, connectionConfig, propsFragments, result, setResult, totalCount, callback, refetchVariables);
    }
    function hasMore() {
        return prev.fragmentPagination.hasMore(result);
    }
    function isLoading() {
        return prev.fragmentPagination.isLoading();
    }
    return [
        result.data && result.data.frag ? Array.isArray(result.data.frag) ? result.data.frag : __assign({}, result.data.frag) : {},
        { refetch: refetch, loadMore: loadMore, hasMore: hasMore, isLoading: isLoading, refetchConnection: refetchConnection }
    ];
};
exports.default = useOssFragment;
/**
 * use case?
      // Otherwise, for convenience short-circuit if all non-Relay props
      // are scalar and equal
      const keys = Object.keys(nextProps);
      for (let ii = 0; ii < keys.length; ii++) {
        const key = keys[ii];
        if (key === '__relayContext') {
          if (
            nextState.prevPropsContext.environment !==
              this.state.prevPropsContext.environment ||
            nextState.prevPropsContext.variables !==
              this.state.prevPropsContext.variables
          ) {
            return true;
          }
        } else {
          if (
            !fragments.hasOwnProperty(key) &&
            !isScalarAndEqual(nextProps[key], this.props[key])
          ) {
            return true;
          }
        }
      }
 */
