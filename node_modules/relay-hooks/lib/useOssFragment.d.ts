import { Observer } from 'relay-runtime';
import { ConnectionConfig } from "./FragmentPagination";
export declare type RefetchOptions = {
    force?: boolean;
    fetchPolicy?: 'store-or-network' | 'network-only';
};
export declare type PaginationFunction = {
    loadMore: (connectionConfig: ConnectionConfig, pageSize: number, observerOrCallback: any, options: RefetchOptions) => any;
    hasMore: () => boolean;
    isLoading: () => boolean;
    refetchConnection: (connectionConfig: ConnectionConfig, totalCount: number, callback: any, refetchVariables: any) => any;
};
export declare type RefetchFunction = (taggedNode: any, refetchVariables: any, renderVariables: any, observerOrCallback: any, options: RefetchOptions) => {
    dispose(): void;
};
interface OssFragmentFunction extends PaginationFunction {
    refetch: RefetchFunction;
}
export declare type ObserverOrCallback = Observer<void> | ((error: Error) => any);
declare const useOssFragment: (fragmentDef: any, fragmentRef: any) => [any, OssFragmentFunction];
export default useOssFragment;
/**
 * use case?
      // Otherwise, for convenience short-circuit if all non-Relay props
      // are scalar and equal
      const keys = Object.keys(nextProps);
      for (let ii = 0; ii < keys.length; ii++) {
        const key = keys[ii];
        if (key === '__relayContext') {
          if (
            nextState.prevPropsContext.environment !==
              this.state.prevPropsContext.environment ||
            nextState.prevPropsContext.variables !==
              this.state.prevPropsContext.variables
          ) {
            return true;
          }
        } else {
          if (
            !fragments.hasOwnProperty(key) &&
            !isScalarAndEqual(nextProps[key], this.props[key])
          ) {
            return true;
          }
        }
      }
 */
