"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var relay_runtime_1 = require("relay-runtime");
var ReactRelayQueryFetcher = require("react-relay/lib/ReactRelayQueryFetcher");
var invariant = require("fbjs/lib/invariant");
var warning = require("fbjs/lib/warning");
var areEqual = require("fbjs/lib/areEqual");
var FORWARD = 'forward';
function findConnectionMetadata(fragments) {
    var foundConnectionMetadata = null;
    var isRelayModern = false;
    for (var fragmentName in fragments) {
        var fragment = fragments[fragmentName];
        var connectionMetadata = (fragment.metadata &&
            fragment.metadata.connection);
        // HACK: metadata is always set to `undefined` in classic. In modern, even
        // if empty, it is set to null (never undefined). We use that knowlege to
        // check if we're dealing with classic or modern
        if (fragment.metadata !== undefined) {
            isRelayModern = true;
        }
        if (connectionMetadata) {
            invariant(connectionMetadata.length === 1, 'ReactRelayPaginationContainer: Only a single @connection is ' +
                'supported, `%s` has %s.', fragmentName, connectionMetadata.length);
            invariant(!foundConnectionMetadata, 'ReactRelayPaginationContainer: Only a single fragment with ' +
                '@connection is supported.');
            foundConnectionMetadata = __assign({}, connectionMetadata[0], { fragmentName: fragmentName });
        }
    }
    invariant(!isRelayModern || foundConnectionMetadata !== null, 'ReactRelayPaginationContainer: A @connection directive must be present.');
    return foundConnectionMetadata || {};
}
function createGetConnectionFromProps(metadata) {
    var path = metadata.path;
    invariant(path, 'ReactRelayPaginationContainer: Unable to synthesize a ' +
        'getConnectionFromProps function.');
    return function (props) {
        var data = props[metadata.fragmentName];
        for (var i = 0; i < path.length; i++) {
            if (!data || typeof data !== 'object') {
                return null;
            }
            data = data[path[i]];
        }
        return data;
    };
}
function createGetFragmentVariables(metadata) {
    var countVariable = metadata.count;
    invariant(countVariable, 'ReactRelayPaginationContainer: Unable to synthesize a ' +
        'getFragmentVariables function.');
    return function (prevVars, totalCount) {
        var _a;
        return (__assign({}, prevVars, (_a = {}, _a[countVariable] = totalCount, _a)));
    };
}
function toObserver(observerOrCallback) {
    return typeof observerOrCallback === 'function'
        ? {
            error: observerOrCallback,
            complete: observerOrCallback,
            unsubscribe: function (subscription) {
                typeof observerOrCallback === 'function' && observerOrCallback();
            },
        }
        : observerOrCallback || {};
}
var FragmentPagination = /** @class */ (function () {
    function FragmentPagination() {
        var _this = this;
        this.hasMore = function (prevResult) {
            _this.init(prevResult);
            var connectionData = _this._getConnectionData(prevResult.data);
            return !!(connectionData &&
                connectionData.hasMore &&
                connectionData.cursor);
        };
        this.isLoading = function () {
            return !!_this._refetchSubscription;
        };
        this.refetchConnection = function (environment, connectionConfig, props, prevResult, setResult, totalCount, observerOrCallback, refetchVariables) {
            _this.init(prevResult);
            _this._refetchVariables = refetchVariables;
            var paginatingVariables = {
                count: totalCount,
                cursor: null,
                totalCount: totalCount,
            };
            var fetch = _this._fetchPage(environment, prevResult, setResult, connectionConfig, props, paginatingVariables, toObserver(observerOrCallback), { force: true });
            return { dispose: fetch.unsubscribe };
        };
        this._queryFetcher = new ReactRelayQueryFetcher();
        this._isARequestInFlight = false;
        this._refetchSubscription = null;
        this._hasFetched = false;
    }
    FragmentPagination.prototype.init = function (prevResult) {
        if (!this._init) {
            var metadata = findConnectionMetadata(prevResult.resolver._fragments);
            this._getConnectionFromProps =
                createGetConnectionFromProps(metadata);
            this._direction = metadata.direction;
            invariant(this._direction, 'ReactRelayPaginationContainer: Unable to infer direction of the ' +
                'connection, possibly because both first and last are provided.');
            this._getFragmentVariables = createGetFragmentVariables(metadata);
            this._init = true;
        }
    };
    FragmentPagination.prototype.dispose = function () {
        this._cleanup();
    };
    FragmentPagination.prototype._cleanup = function () {
        this._hasFetched = false;
        if (this._refetchSubscription) {
            this._refetchSubscription.unsubscribe();
            this._refetchSubscription = null;
            this._isARequestInFlight = false;
        }
        if (this._queryFetcher) {
            this._queryFetcher.dispose();
        }
    };
    FragmentPagination.prototype._getConnectionData = function (data) {
        // Extract connection data and verify there are more edges to fetch
        var props = __assign({}, data);
        var connectionData = this._getConnectionFromProps(props);
        if (connectionData == null) {
            return null;
        }
        var _a = relay_runtime_1.ConnectionInterface.get(), EDGES = _a.EDGES, PAGE_INFO = _a.PAGE_INFO, HAS_NEXT_PAGE = _a.HAS_NEXT_PAGE, HAS_PREV_PAGE = _a.HAS_PREV_PAGE, END_CURSOR = _a.END_CURSOR, START_CURSOR = _a.START_CURSOR;
        invariant(typeof connectionData === 'object', 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +
            'to return `null` or a plain object with %s and %s properties, got `%s`.', 'useFragment pagination', EDGES, PAGE_INFO, connectionData);
        var edges = connectionData[EDGES];
        var pageInfo = connectionData[PAGE_INFO];
        if (edges == null || pageInfo == null) {
            return null;
        }
        invariant(Array.isArray(edges), 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +
            'to return an object with %s: Array, got `%s`.', 'useFragment pagination', EDGES, edges);
        invariant(typeof pageInfo === 'object', 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +
            'to return an object with %s: Object, got `%s`.', 'useFragment pagination', PAGE_INFO, pageInfo);
        var hasMore = this._direction === FORWARD
            ? pageInfo[HAS_NEXT_PAGE]
            : pageInfo[HAS_PREV_PAGE];
        var cursor = this._direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];
        if (typeof hasMore !== 'boolean' ||
            (edges.length !== 0 && typeof cursor === 'undefined')) {
            warning(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' +
                'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, 'useFragment pagination', this._direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, this._direction === FORWARD ? END_CURSOR : START_CURSOR, cursor);
            return null;
        }
        return {
            cursor: cursor,
            edgeCount: edges.length,
            hasMore: hasMore,
        };
    };
    FragmentPagination.prototype.loadMore = function (environment, connectionConfig, props, pageSize, observerOrCallback, options, prevResult, setResult) {
        this.init(prevResult);
        var observer = toObserver(observerOrCallback);
        var connectionData = this._getConnectionData(prevResult.data);
        if (!connectionData) {
            relay_runtime_1.Observable.create(function (sink) { return sink.complete(); }).subscribe(observer);
            return null;
        }
        var totalCount = connectionData.edgeCount + pageSize;
        if (options && options.force) {
            return this.refetchConnection(environment, connectionConfig, props, prevResult, setResult, totalCount, observerOrCallback, undefined);
        }
        var _a = relay_runtime_1.ConnectionInterface.get(), END_CURSOR = _a.END_CURSOR, START_CURSOR = _a.START_CURSOR;
        var cursor = connectionData.cursor;
        warning(cursor, 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', this._direction === FORWARD ? END_CURSOR : START_CURSOR, cursor);
        var paginatingVariables = {
            count: pageSize,
            cursor: cursor,
            totalCount: totalCount,
        };
        var fetch = this._fetchPage(environment, prevResult, setResult, connectionConfig, props, paginatingVariables, observer, options);
        return { dispose: fetch.unsubscribe };
    };
    ;
    FragmentPagination.prototype._fetchPage = function (environment, prevResult, setResult, connectionConfig, propsFragment, paginatingVariables, observer, options) {
        var _this = this;
        //const { componentRef: _, __relayContext, ...restProps } = this.props;
        var resolver = prevResult.resolver;
        var props = prevResult.data && prevResult.data.frag ? prevResult.data.frag : {};
        var fragments = prevResult.resolver._fragments;
        var rootVariables;
        var fragmentVariables;
        var fragmentOwners = relay_runtime_1.getFragmentOwners(fragments, propsFragment);
        // NOTE: rootVariables are spread down below in a couple of places,
        // so we compute them here from the fragment owners.
        // For extra safety, we make sure the rootVariables include the
        // variables from all owners in this fragmentSpec, even though they
        // should all point to the same owner
        Object.keys(fragments).forEach(function (key) {
            var fragmentOwner = fragmentOwners[key];
            var fragmentOwnerVariables = Array.isArray(fragmentOwner)
                ? fragmentOwner[0].variables || {}
                : fragmentOwner.variables || {};
            rootVariables = __assign({}, rootVariables, fragmentOwnerVariables);
        });
        // hack 6.0.0
        if (relay_runtime_1.getVariablesFromObject.length === 2) {
            fragmentVariables = relay_runtime_1.getVariablesFromObject(fragments, propsFragment);
        }
        else {
            fragmentVariables = relay_runtime_1.getVariablesFromObject(
            // NOTE: We pass empty operationVariables because we want to prefer
            // the variables from the fragment owner
            {}, fragments, propsFragment, fragmentOwners);
        }
        fragmentVariables = __assign({}, rootVariables, fragmentVariables, this._refetchVariables);
        var fetchVariables = connectionConfig.getVariables(props, {
            count: paginatingVariables.count,
            cursor: paginatingVariables.cursor,
        }, fragmentVariables);
        invariant(typeof fetchVariables === 'object' && fetchVariables !== null, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' +
            'return an object, got `%s` in `%s`.', fetchVariables, 'useFragment pagination');
        fetchVariables = __assign({}, fetchVariables, this._refetchVariables);
        fragmentVariables = __assign({}, fetchVariables, fragmentVariables);
        var cacheConfig = options
            ? { force: !!options.force }
            : undefined;
        if (cacheConfig != null && options && options.metadata != null) {
            cacheConfig.metadata = options.metadata;
        }
        var request = relay_runtime_1.getRequest(connectionConfig.query);
        var operation = relay_runtime_1.createOperationDescriptor(request, fetchVariables);
        var refetchSubscription = null;
        if (this._refetchSubscription) {
            this._refetchSubscription.unsubscribe();
        }
        this._hasFetched = true;
        var onNext = function (payload, complete) {
            var contextVariables = __assign({}, fragmentVariables);
            var prevData = resolver.resolve();
            resolver.setVariables(_this._getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.node || operation.request.node);
            var nextData = resolver.resolve();
            // Workaround slightly different handling for connection in different
            // core implementations:
            // - Classic core requires the count to be explicitly incremented
            // - Modern core automatically appends new items, updating the count
            //   isn't required to see new data.
            //
            // `setState` is only required if changing the variables would change the
            // resolved data.
            // TODO #14894725: remove PaginationContainer equal check
            if (!areEqual(prevData, nextData)) {
                //res.setVariables(contextVariables, operation.node);
                setResult({
                    resolver: resolver, data: nextData, relay: {
                        environment: environment,
                        variables: contextVariables,
                    }
                });
                var callComplete = function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        complete();
                        return [2 /*return*/];
                    });
                }); };
                callComplete();
                /*this.setState(
                    {
                        data: nextData,
                        contextForChildren: {
                            environment: this.props.__relayContext.environment,
                            variables: contextVariables,
                        },
                    },
                    complete,
                );*/
            }
            else {
                complete();
            }
        };
        var cleanup = function () {
            if (_this._refetchSubscription === refetchSubscription) {
                _this._refetchSubscription = null;
                _this._isARequestInFlight = false;
            }
        };
        this._isARequestInFlight = true;
        refetchSubscription = this._queryFetcher
            .execute({
            environment: environment,
            operation: operation,
            cacheConfig: cacheConfig,
            preservePreviousReferences: true,
        })
            .mergeMap(function (payload) {
            return relay_runtime_1.Observable.create(function (sink) {
                onNext(payload, function () {
                    sink.next(); // pass void to public observer's `next`
                    sink.complete();
                });
            });
        })
            // use do instead of finally so that observer's `complete` fires after cleanup
            .do({
            error: cleanup,
            complete: cleanup,
            unsubscribe: cleanup,
        })
            .subscribe(observer || {});
        this._refetchSubscription = this._isARequestInFlight
            ? refetchSubscription
            : null;
        return refetchSubscription;
    };
    return FragmentPagination;
}());
exports.default = FragmentPagination;
