import { ConnectionArguments } from 'graphql-relay';
import mongoose, { Query } from 'mongoose';
declare type ObjectId = mongoose.Schema.Types.ObjectId;
export declare const PREFIX = "mongo:";
export declare const base64: (str: string) => string;
export declare const unbase64: (b64: string) => string;
/**
 * Rederives the offset from the cursor string
 */
export declare const cursorToOffset: (cursor: string) => number;
/**
 * Given an optional cursor and a default offset, returns the offset to use;
 * if the cursor contains a valid offset, that will be used, otherwise it will
 * be the default.
 */
export declare const getOffsetWithDefault: (cursor: string | null, defaultOffset: number) => number;
/**
 * Creates the cursor string from an offset.
 */
export declare const offsetToCursor: (offset: number) => string;
export declare type TotalCountOptions = {
    cursor: Query<any>;
    useEstimatedCount?: boolean;
    lean: boolean;
};
export declare const getTotalCount: ({ cursor, useEstimatedCount, lean }: TotalCountOptions) => Promise<number>;
export declare type OffsetOptions = {
    args: ConnectionArguments;
    totalCount: number;
};
export declare type PageInfoOffsets = {
    before: string | null;
    after: string | null;
    first: number | null;
    last: number | null;
    afterOffset: number;
    beforeOffset: number;
    startOffset: number;
    endOffset: number;
    startCursorOffset: number;
    endCursorOffset: number;
};
export declare type Offsets = PageInfoOffsets & {
    skip: number;
    limit: number;
};
export declare type PageInfoOptions<NodeType> = PageInfoOffsets & {
    edges: Array<{
        cursor: string;
        node: NodeType;
    }>;
    totalCount: number;
};
export declare const calculateOffsets: ({ args, totalCount }: OffsetOptions) => Offsets;
export declare function getPageInfo<NodeType>({ edges, totalCount, startCursorOffset, endCursorOffset, }: PageInfoOptions<NodeType>): {
    startCursor: string | null;
    endCursor: string | null;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
};
export declare type ConnectionOptionsCursor<LoaderResult, Ctx> = {
    cursor: Query<any>;
    context: Ctx;
    args: ConnectionArguments;
    loader: (ctx: Ctx, id: string | ObjectId | object) => LoaderResult;
    raw?: boolean;
    useEstimatedCount?: boolean;
    lean?: boolean;
};
declare function connectionFromMongoCursor<LoaderResult, Ctx>({ cursor, context, args, loader, raw, useEstimatedCount, lean, }: ConnectionOptionsCursor<LoaderResult, Ctx>): Promise<{
    edges: {
        cursor: string;
        node: LoaderResult;
    }[];
    count: number;
    endCursorOffset: number;
    startCursorOffset: number;
    pageInfo: {
        startCursor: string | null;
        endCursor: string | null;
        hasPreviousPage: boolean;
        hasNextPage: boolean;
    };
}>;
export default connectionFromMongoCursor;
