{"version":3,"sources":["../src/ConnectionFromMongoCursor.ts"],"names":["PREFIX","base64","str","Buffer","from","toString","unbase64","b64","cursorToOffset","cursor","parseInt","substring","length","getOffsetWithDefault","defaultOffset","undefined","offset","isNaN","offsetToCursor","getTotalCount","useEstimatedCount","lean","clonedCursor","model","find","merge","estimatedDocumentCount","countDocuments","calculateOffsets","args","totalCount","after","before","first","last","beforeOffset","afterOffset","startOffset","Math","max","endOffset","min","skip","safeLimit","limitOffset","limit","startCursorOffset","endCursorOffset","getPageInfo","edges","firstEdge","lastEdge","startCursor","endCursor","hasPreviousPage","hasNextPage","connectionFromMongoCursor","context","loader","raw","slice","select","_id","exec","map","value","index","node","count","pageInfo"],"mappings":"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","sourcesContent":["import { ConnectionArguments } from 'graphql-relay';\nimport mongoose, { Query } from 'mongoose';\ntype ObjectId = mongoose.Schema.Types.ObjectId;\n\nexport const PREFIX = 'mongo:';\n\nexport const base64 = (str: string): string => Buffer.from(str, 'ascii').toString('base64');\nexport const unbase64 = (b64: string): string => Buffer.from(b64, 'base64').toString('ascii');\n\n/**\n * Rederives the offset from the cursor string\n */\nexport const cursorToOffset = (cursor: string): number =>\n  parseInt(unbase64(cursor).substring(PREFIX.length), 10);\n\n/**\n * Given an optional cursor and a default offset, returns the offset to use;\n * if the cursor contains a valid offset, that will be used, otherwise it will\n * be the default.\n */\nexport const getOffsetWithDefault = (cursor: string | null, defaultOffset: number): number => {\n  if (cursor === undefined || cursor === null) {\n    return defaultOffset;\n  }\n  const offset = cursorToOffset(cursor);\n  return isNaN(offset) ? defaultOffset : offset;\n};\n\n/**\n * Creates the cursor string from an offset.\n */\nexport const offsetToCursor = (offset: number): string => base64(PREFIX + offset);\n\nexport type TotalCountOptions = {\n  cursor: Query<any>,\n  useEstimatedCount?: boolean,\n  lean: boolean,\n};\n\nexport const getTotalCount = async ({ cursor, useEstimatedCount = false, lean = true }: TotalCountOptions): Promise<number> => {\n  // @ts-ignore\n  const clonedCursor = lean ? cursor.model.find().lean().merge(cursor) : cursor.model.find().merge(cursor);\n\n  return useEstimatedCount ? clonedCursor.estimatedDocumentCount() : clonedCursor.countDocuments();\n};\n\nexport type OffsetOptions = {\n  // Connection Args\n  args: ConnectionArguments,\n  // total Count\n  totalCount: number,\n};\n\nexport type PageInfoOffsets = {\n  before: string | null,\n  after: string | null,\n  first: number | null,\n  last: number | null,\n  afterOffset: number,\n  beforeOffset: number,\n  startOffset: number,\n  endOffset: number,\n  startCursorOffset: number,\n  endCursorOffset: number,\n};\n\nexport type Offsets = PageInfoOffsets & {\n  skip: number,\n  limit: number,\n};\n\nexport type PageInfoOptions<NodeType> = PageInfoOffsets & {\n  edges: Array<{\n    cursor: string,\n    node: NodeType,\n  }>,\n  totalCount: number,\n};\n\nexport const calculateOffsets = ({ args, totalCount }: OffsetOptions): Offsets => {\n  const { after, before } = args;\n  let { first, last } = args;\n\n  // Limit the maximum number of elements in a query\n  if (!first && !last) first = 10;\n  if (first && first > 1000) first = 1000;\n  if (last && last > 1000) last = 1000;\n\n  const beforeOffset = getOffsetWithDefault(before || null, totalCount);\n  const afterOffset = getOffsetWithDefault(after || null, -1);\n\n  let startOffset = Math.max(-1, afterOffset) + 1;\n  let endOffset = Math.min(totalCount, beforeOffset);\n\n  if (first !== undefined && first !== null) {\n    endOffset = Math.min(endOffset, startOffset + first);\n  }\n\n  if (last !== undefined && last !== null) {\n    startOffset = Math.max(startOffset, endOffset - (last || 0));\n  }\n\n  const skip = Math.max(startOffset, 0);\n\n  const safeLimit = Math.max(endOffset - startOffset, 1);\n  const limitOffset = Math.max(endOffset - startOffset, 0);\n\n  return {\n    first: first || null,\n    last: last || null,\n    before: before || null,\n    after: after || null,\n    skip,\n    limit: safeLimit,\n    beforeOffset,\n    afterOffset,\n    startOffset,\n    endOffset,\n    startCursorOffset: skip,\n    endCursorOffset: limitOffset + skip,\n  };\n};\n\nexport function getPageInfo<NodeType>({\n  edges,\n  // before,\n  // after,\n  // first,\n  // last,\n  // afterOffset,\n  // beforeOffset,\n  // startOffset,\n  // endOffset,\n  totalCount,\n  startCursorOffset,\n  endCursorOffset,\n}: PageInfoOptions<NodeType>) {\n  const firstEdge = edges[0];\n  const lastEdge = edges[edges.length - 1];\n\n  // const lowerBound = after ? afterOffset + 1 : 0;\n  // const upperBound = before ? Math.min(beforeOffset, totalCount) : totalCount;\n\n  return {\n    startCursor: firstEdge ? firstEdge.cursor : null,\n    endCursor: lastEdge ? lastEdge.cursor : null,\n    hasPreviousPage: startCursorOffset > 0,\n    hasNextPage: endCursorOffset < totalCount,\n    // hasPreviousPage: last !== null ? startOffset > lowerBound : false,\n    // hasNextPage: first !== null ? endOffset < upperBound : false,\n  };\n}\n\nexport type ConnectionOptionsCursor<LoaderResult, Ctx> = {\n  cursor: Query<any>,\n  context: Ctx,\n  args: ConnectionArguments,\n  loader: (ctx: Ctx, id: string | ObjectId | object) => LoaderResult,\n  raw?: boolean, // loader should receive raw result\n  useEstimatedCount?: boolean,\n  lean?: boolean,\n};\n\nasync function connectionFromMongoCursor<LoaderResult, Ctx>({\n  cursor,\n  context,\n  args = {},\n  loader,\n  raw = false,\n  useEstimatedCount = false,\n  lean = true,\n}: ConnectionOptionsCursor<LoaderResult, Ctx>) {\n  // @ts-ignore\n  const clonedCursor = lean ? cursor.model.find().lean().merge(cursor) : cursor.model.find().merge(cursor);\n\n  const totalCount: number = await getTotalCount({\n    cursor: clonedCursor,\n    useEstimatedCount,\n    lean,\n  });\n\n  const {\n    first,\n    last,\n    before,\n    after,\n    skip,\n    limit,\n    beforeOffset,\n    afterOffset,\n    startOffset,\n    endOffset,\n    startCursorOffset,\n    endCursorOffset,\n  } = calculateOffsets({ args, totalCount });\n\n  // If supplied slice is too large, trim it down before mapping over it.\n  clonedCursor.skip(skip);\n  clonedCursor.limit(limit);\n\n  // avoid large objects retrieval from collection\n  const slice: Array<{ _id: ObjectId }> = await clonedCursor.select(raw ? {} : { _id: 1 }).exec();\n\n  const edges: Array<{\n    cursor: string,\n    node: LoaderResult,\n  }> = slice.map((value, index) => ({\n    cursor: offsetToCursor(startOffset + index),\n    node: loader(context, raw ? value : value._id),\n  }));\n\n  return {\n    edges,\n    count: totalCount,\n    endCursorOffset,\n    startCursorOffset,\n    pageInfo: getPageInfo({\n      edges,\n      before,\n      after,\n      first,\n      last,\n      afterOffset,\n      beforeOffset,\n      startOffset,\n      endOffset,\n      totalCount,\n      startCursorOffset,\n      endCursorOffset,\n    }),\n  };\n}\n\nexport default connectionFromMongoCursor;\n"],"file":"ConnectionFromMongoCursor.js"}