{"version":3,"sources":["../src/ConnectionFromMongoAggregate.ts"],"names":["cloneAggregate","aggregate","_model","pipeline","connectionFromMongoAggregate","context","args","loader","raw","allowDiskUse","clonedAggregate","resultCount","count","totalCount","length","total","first","last","before","after","skip","limit","beforeOffset","afterOffset","startOffset","endOffset","startCursorOffset","endCursorOffset","slice","project","edges","map","value","index","cursor","node","_id","pageInfo"],"mappings":";;;;;;;AAGA;;;;;;AAGA,MAAMA,cAAc,GAAIC,SAAD,IACrB;AACAA,SAAS,CAACC,MAAV,CAAiBD,SAAjB,CAA2BA,SAAS,CAACE,QAAV,EAA3B,CAFF;;AAaA;;;;SAIeC,4B;;;;;oDAAf,WAA+D;AAC7DH,IAAAA,SAD6D;AAE7DI,IAAAA,OAF6D;AAG7DC,IAAAA,IAAI,GAAG,EAHsD;AAI7DC,IAAAA,MAJ6D;AAK7DC,IAAAA,GAAG,GAAG,KALuD;AAM7DC,IAAAA,YAAY,GAAG;AAN8C,GAA/D,EAOkD;AAChD;AACA,UAAMC,eAAe,GAAGV,cAAc,CAACC,SAAD,CAAd,CAA0BQ,YAA1B,CAAuCA,YAAvC,CAAxB;AAEA,UAAME,WAAqC,SAASX,cAAc,CAACC,SAAD,CAAd,CACjDQ,YADiD,CACpCA,YADoC,EAEjDG,KAFiD,CAE3C,OAF2C,CAApD;AAGA,UAAMC,UAAU,GAAGF,WAAW,CAACG,MAAZ,GAAqBH,WAAW,CAAC,CAAD,CAAX,CAAeI,KAApC,GAA4C,CAA/D;AAEA,UAAM;AACJC,MAAAA,KADI;AAEJC,MAAAA,IAFI;AAGJC,MAAAA,MAHI;AAIJC,MAAAA,KAJI;AAKJC,MAAAA,IALI;AAMJC,MAAAA,KANI;AAOJC,MAAAA,YAPI;AAQJC,MAAAA,WARI;AASJC,MAAAA,WATI;AAUJC,MAAAA,SAVI;AAWJC,MAAAA,iBAXI;AAYJC,MAAAA;AAZI,QAaF,iDAAiB;AAAErB,MAAAA,IAAF;AAAQO,MAAAA;AAAR,KAAjB,CAbJ,CATgD,CAwBhD;;AACAH,IAAAA,eAAe,CAACU,IAAhB,CAAqBA,IAArB,EAzBgD,CA0BhD;;AACAV,IAAAA,eAAe,CAACW,KAAhB,CAAsBA,KAAK,IAAI,CAA/B,EA3BgD,CA6BhD;;AACA,UAAMO,KAA+B,SAAUpB,GAAG,GAC9CE,eAD8C,GAE9CA,eAAe,CAACmB,OAAhB,CAAwB,KAAxB,CAFJ;AAIA,UAAMC,KAGJ,GAAGF,KAAK,CAACG,GAAN,CAAU,CAACC,KAAD,EAAQC,KAAR,MAAmB;AAChCC,MAAAA,MAAM,EAAE,+CAAeV,WAAW,GAAGS,KAA7B,CADwB;AAEhCE,MAAAA,IAAI,EAAE5B,MAAM,CAACF,OAAD,EAAUG,GAAG,GAAGwB,KAAH,GAAWA,KAAK,CAACI,GAA9B;AAFoB,KAAnB,CAAV,CAHL;AAQA,WAAO;AACLN,MAAAA,KADK;AAELlB,MAAAA,KAAK,EAAEC,UAFF;AAGLc,MAAAA,eAHK;AAILD,MAAAA,iBAJK;AAKLW,MAAAA,QAAQ,EAAE,4CAAY;AACpBP,QAAAA,KADoB;AAEpBZ,QAAAA,MAFoB;AAGpBC,QAAAA,KAHoB;AAIpBH,QAAAA,KAJoB;AAKpBC,QAAAA,IALoB;AAMpBM,QAAAA,WANoB;AAOpBD,QAAAA,YAPoB;AAQpBE,QAAAA,WARoB;AASpBC,QAAAA,SAToB;AAUpBZ,QAAAA,UAVoB;AAWpBa,QAAAA,iBAXoB;AAYpBC,QAAAA;AAZoB,OAAZ;AALL,KAAP;AAoBD,G;;;;eAEcvB,4B","sourcesContent":["import { ConnectionArguments } from 'graphql-relay';\nimport mongoose, { Aggregate } from 'mongoose';\n\nimport { calculateOffsets, getPageInfo, offsetToCursor } from './ConnectionFromMongoCursor';\ntype ObjectId = mongoose.Schema.Types.ObjectId;\n\nconst cloneAggregate = (aggregate: Aggregate<any>): Aggregate<any> =>\n  // @ts-ignore\n  aggregate._model.aggregate(aggregate.pipeline());\n\nexport type ConnectionOptionsAggregate<LoaderResult, Ctx> = {\n  aggregate: Aggregate<any>,\n  context: Ctx,\n  args: ConnectionArguments,\n  loader: (ctx: Ctx, id: string | ObjectId | Object) => LoaderResult,\n  raw?: boolean, // loader should receive raw result\n  allowDiskUse?: boolean,\n};\n\n/**\n * Your aggregate must return documents with _id fields\n *  those _id's are the ones going to be passed to the loader function\n */\nasync function connectionFromMongoAggregate<LoaderResult, Ctx>({\n  aggregate,\n  context,\n  args = {},\n  loader,\n  raw = false,\n  allowDiskUse = false,\n}: ConnectionOptionsAggregate<LoaderResult, Ctx>) {\n  // https://github.com/Automattic/mongoose/blob/367261e6c83e7e367cf0d3fbd2edea4c64bf1ee2/lib/aggregate.js#L46\n  const clonedAggregate = cloneAggregate(aggregate).allowDiskUse(allowDiskUse);\n\n  const resultCount: Array<{ total: number }> = await cloneAggregate(aggregate)\n    .allowDiskUse(allowDiskUse)\n    .count('total');\n  const totalCount = resultCount.length ? resultCount[0].total : 0;\n\n  const {\n    first,\n    last,\n    before,\n    after,\n    skip,\n    limit,\n    beforeOffset,\n    afterOffset,\n    startOffset,\n    endOffset,\n    startCursorOffset,\n    endCursorOffset,\n  } = calculateOffsets({ args, totalCount });\n\n  // If supplied slice is too large, trim it down before mapping over it.\n  clonedAggregate.skip(skip);\n  // limit should never be 0 because $slice returns an error if it is.\n  clonedAggregate.limit(limit || 1);\n\n  // avoid large objects retrieval from collection\n  const slice: Array<{ _id: ObjectId }> = await (raw\n    ? clonedAggregate\n    : clonedAggregate.project('_id'));\n\n  const edges: Array<{\n    cursor: string,\n    node: LoaderResult,\n  }> = slice.map((value, index) => ({\n    cursor: offsetToCursor(startOffset + index),\n    node: loader(context, raw ? value : value._id),\n  }));\n\n  return {\n    edges,\n    count: totalCount,\n    endCursorOffset,\n    startCursorOffset,\n    pageInfo: getPageInfo({\n      edges,\n      before,\n      after,\n      first,\n      last,\n      afterOffset,\n      beforeOffset,\n      startOffset,\n      endOffset,\n      totalCount,\n      startCursorOffset,\n      endCursorOffset,\n    }),\n  };\n}\n\nexport default connectionFromMongoAggregate;\n"],"file":"ConnectionFromMongoAggregate.js"}