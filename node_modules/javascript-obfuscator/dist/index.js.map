{"version":3,"sources":["webpack://JavaScriptObfuscator/webpack/bootstrap","webpack://JavaScriptObfuscator/external \"inversify\"","webpack://JavaScriptObfuscator/external \"tslib\"","webpack://JavaScriptObfuscator/./src/container/ServiceIdentifiers.ts","webpack://JavaScriptObfuscator/./src/node/NodeGuards.ts","webpack://JavaScriptObfuscator/./src/decorators/Initializable.ts","webpack://JavaScriptObfuscator/./src/node/NodeUtils.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/TransformationStage.ts","webpack://JavaScriptObfuscator/./src/node-transformers/AbstractNodeTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeFactory.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNode.ts","webpack://JavaScriptObfuscator/external \"estraverse\"","webpack://JavaScriptObfuscator/./src/node/NodeMetadata.ts","webpack://JavaScriptObfuscator/./src/enums/node/NodeType.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/container/InversifyContainerFacade.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack://JavaScriptObfuscator/./src/node/NodeAppender.ts","webpack://JavaScriptObfuscator/./src/enums/ObfuscationTarget.ts","webpack://JavaScriptObfuscator/./src/node/NodeStatementUtils.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/NodeTransformer.ts","webpack://JavaScriptObfuscator/./src/enums/event-emitters/ObfuscationEvent.ts","webpack://JavaScriptObfuscator/./src/node/NodeLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNode.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorFacade.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/utils/Utils.ts","webpack://JavaScriptObfuscator/./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/enums/source-map/SourceMapMode.ts","webpack://JavaScriptObfuscator/./src/enums/StringArrayEncoding.ts","webpack://JavaScriptObfuscator/external \"@gradecam/tsenum\"","webpack://JavaScriptObfuscator/./src/options/presets/NoCustomNodes.ts","webpack://JavaScriptObfuscator/./src/utils/NumberUtils.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"escodegen\"","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AbstractPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableNoEvalTemplate.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/options/presets/Default.ts","webpack://JavaScriptObfuscator/./src/enums/StringSeparator.ts","webpack://JavaScriptObfuscator/./src/enums/analyzers/calls-graph-analyzer/CalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"espree\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ObjectExpressionKeysTransformerCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/storages/MapStorage.ts","webpack://JavaScriptObfuscator/./src/utils/RandomGenerator.ts","webpack://JavaScriptObfuscator/external \"chalk\"","webpack://JavaScriptObfuscator/external \"reflect-metadata\"","webpack://JavaScriptObfuscator/./src/logger/Logger.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingPrefix.ts","webpack://JavaScriptObfuscator/./src/container/modules/analyzers/AnalyzersModule.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/BasePropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/SplitStringTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/object-expression-keys-transformer-nodes/BasePropertiesExtractorObjectExpressionHostNode.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate1.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate2.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack://JavaScriptObfuscator/./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/CustomNodeFormatter.ts","webpack://JavaScriptObfuscator/external \"string-template\"","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack://JavaScriptObfuscator/./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/SingleNodeCallControllerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack://JavaScriptObfuscator/./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack://JavaScriptObfuscator/./src/templates/AtobTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/Rc4Template.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/generators/GeneratorsModule.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/DictionaryIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ImportDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeBlockLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/./src/container/modules/options/OptionsModule.ts","webpack://JavaScriptObfuscator/./src/options/Options.ts","webpack://JavaScriptObfuscator/external \"class-validator\"","webpack://JavaScriptObfuscator/./src/options/ValidationErrorsFormatter.ts","webpack://JavaScriptObfuscator/./src/options/OptionsNormalizer.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DomainLockRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/InputFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SeedRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SelfDefendingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SplitStringsChunkLengthRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/EvalCallExpressionTransformer.ts","webpack://JavaScriptObfuscator/external \"js-string-escape\"","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/MetadataTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ReservedStringObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/VariablePreserveTransformer.ts","webpack://JavaScriptObfuscator/./src/container/modules/storages/StoragesModule.ts","webpack://JavaScriptObfuscator/./src/storages/control-flow/ControlFlowStorage.ts","webpack://JavaScriptObfuscator/./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack://JavaScriptObfuscator/./src/storages/string-array/StringArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/ArrayStorage.ts","webpack://JavaScriptObfuscator/./src/container/modules/utils/UtilsModule.ts","webpack://JavaScriptObfuscator/./src/utils/ArrayUtils.ts","webpack://JavaScriptObfuscator/./src/utils/CryptUtils.ts","webpack://JavaScriptObfuscator/external \"md5\"","webpack://JavaScriptObfuscator/external \"chance\"","webpack://JavaScriptObfuscator/./src/utils/EscapeSequenceEncoder.ts","webpack://JavaScriptObfuscator/./src/utils/LevelledTopologicalSorter.ts","webpack://JavaScriptObfuscator/./src/utils/NodeTransformerNamesGroupsBuilder.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscator.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingMessage.ts","webpack://JavaScriptObfuscator/./src/EspreeFacade.ts","webpack://JavaScriptObfuscator/./src/event-emitters/ObfuscationEventEmitter.ts","webpack://JavaScriptObfuscator/external \"eventemitter3\"","webpack://JavaScriptObfuscator/./src/source-code/ObfuscatedCode.ts","webpack://JavaScriptObfuscator/./src/source-code/SourceCode.ts","webpack://JavaScriptObfuscator/./src/node-transformers/TransformersRunner.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/VisitorDirection.ts","webpack://JavaScriptObfuscator/./index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ServiceIdentifiers","NodeGuards","node","type","NodeType","ArrayPattern","ArrowFunctionExpression","AssignmentExpression","AssignmentPattern","AwaitExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ClassDeclaration","id","ContinueStatement","ExpressionStatement","ExportNamedDeclaration","isForStatementNode","isForInStatementNode","isForOfStatementNode","ForStatement","ForInStatement","ForOfStatement","isFunctionDeclarationNode","isFunctionExpressionNode","isArrowFunctionExpressionNode","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","ImportDeclaration","ImportSpecifier","parentNode","parentNodeIsLabeledStatementNode","isLabeledStatementNode","label","parentNodeIsContinueStatementNode","isContinueStatementNode","parentNodeIsBreakStatementNode","isBreakStatementNode","LabeledStatement","Literal","MemberExpression","MethodDefinition","undefined","isProgramNode","isFunctionNode","isNodeWithLexicalScope","isBlockStatementNode","nodesWithLexicalStatements","includes","isSwitchCaseNode","Boolean","leadingComments","trailingComments","ObjectPattern","ObjectExpression","Program","Property","isPropertyNode","computed","isMemberExpressionNode","isMethodDefinitionNode","isIdentifierNode","parentNodeIsPropertyNode","parentNodeIsMemberExpressionNode","parentNodeIsMethodDefinitionNode","isLabelIdentifierNode","RestElement","ReturnStatement","Super","SwitchCase","TaggedTemplateExpression","TemplateLiteral","UnaryExpression","isDirectiveNode","directive","VariableDeclaration","VariableDeclarator","WhileStatement","defaultDescriptor","configurable","initializeTargetMetadata","metadataKey","metadataValue","target","Reflect","hasMetadata","defineMetadata","initializeMethodName","decoratorName","keys","this","propertyKey","initializeMethod","Error","Set","ownPropertyNames","getOwnPropertyNames","prohibitedPropertyNames","forEach","propertyName","initializablePropertiesSet","getMetadata","wrappedMethodsSet","has","methodDescriptor","getOwnPropertyDescriptor","originalMethod","apply","arguments","add","wrapTargetMethodsInInitializedCheck","result","wrapInitializeMethodInInitializeCheck","initializablePropertyMetadataKey","toString","propertyDescriptor","set","newVal","wrapInitializableProperty","NodeUtils","literalNode","content","raw","precedence","escodegen","Precedence","Primary","astTree","parentizeAst","cloneRecursive","code","structure","espree","parse","ecmaVersion","sourceType","estraverse","replace","enter","parentizeNode","isLiteralNode","addXVerbatimPropertyTo","NodeMetadata","ignoredNode","body","reduce","generate","sourceMapWithCode","unaryExpressionNode","isUnaryExpressionNode","argument","getUnaryExpressionArgumentNode","copy","clonedValue","RegExp","Array","isArray","map","TransformationStage","AbstractNodeTransformer","randomGenerator","options","injectable","inject","IRandomGenerator","IOptions","NodeFactory","metadata","elements","ArrayExpression","operator","left","right","BinaryExpression","callee","args","expression","functionName","params","identifierNode","generator","test","consequent","alternate","LogicalExpression","kind","static","properties","method","shorthand","discriminant","cases","SwitchStatement","prefix","argumentExpr","UpdateExpression","declarations","init","AbstractCustomNode","identifierNamesGeneratorFactory","customNodeFormatter","cachedNode","identifierNamesGenerator","nodeTemplate","getNodeTemplate","formatStructure","getNodeStructure","getRandomGenerator","pickone","globalVariableTemplateFunctions","GlobalVariableTemplate1","GlobalVariableTemplate2","Factory__IIdentifierNamesGenerator","ICustomNodeFormatter","assign","IdentifierObfuscatingReplacer","container","Container","serviceIdentifier","context","bindingName","getNamed","cache","Map","dependencies","cachedDependencies","dependency","index","constructor","named","sourceCode","sourceMap","ISourceCode","toDynamicValue","SourceCode","inSingletonScope","TInputOptions","ILogger","to","Logger","IJavaScriptObfuscator","JavaScriptObfuscator","ITransformersRunner","TransformersRunner","IObfuscatedCode","ObfuscatedCode","Factory__IObfuscatedCode","toFactory","obfuscatedCodeAsString","sourceMapAsString","obfuscatedCode","initialize","IObfuscationEventEmitter","ObfuscationEventEmitter","load","analyzersModule","controlFlowTransformersModule","convertingTransformersModule","customNodesModule","finalizingTransformersModule","generatorsModule","nodeTransformersModule","obfuscatingTransformersModule","optionsModule","preparingTransformersModule","storagesModule","utilsModule","unbindAll","ControlFlowCustomNode","NodeAppender","nodeWithStatements","statements","parentizeScopeStatementsBeforeAppend","setScopeStatements","getScopeStatements","callsGraphData","bodyStatements","targetBlockScope","length","getOptimalBlockScope","prepend","deep","Infinity","firstCall","callsGraph","indexInScopeStatement","indexOf","insertAtIndex","slice","statement","ObfuscationTarget","MakeEnum","Browser","BrowserNoEval","Node","NodeStatementUtils","getParentNodesWithStatementsRecursive","getSiblingStatementByOffset","ReferenceError","isNodeWithStatements","getRootStatementOfNode","getScopeOfNode","maxSize","nodesWithStatements","depth","isNodeWithLexicalScopeStatements","push","offset","scopeNode","scopeBody","indexInScope","NodeTransformer","ObfuscationEvent","NodeLexicalScopeUtils","getLexicalScopesRecursive","nodesWithLexicalScope","CustomNode","JavaScriptObfuscatorFacade","inputOptions","inversifyContainerFacade","InversifyContainerFacade","obfuscate","unload","version","AbstractCustomNodeGroup","appendEvent","customNodes","customNodeName","callback","customNode","callsGraphLength","getRandomInteger","Math","max","round","Utils","url","domain","split","hexadecimalPrefix","IdentifierNamesGenerator","DictionaryIdentifierNamesGenerator","HexadecimalIdentifierNamesGenerator","MangledIdentifierNamesGenerator","SourceMapMode","Inline","Separate","StringArrayEncoding","Base64","Rc4","NO_ADDITIONAL_NODES_PRESET","freeze","compact","controlFlowFlattening","controlFlowFlatteningThreshold","deadCodeInjection","deadCodeInjectionThreshold","debugProtection","debugProtectionInterval","disableConsoleOutput","domainLock","exclude","identifiersPrefix","identifiersDictionary","inputFileName","log","renameGlobals","reservedNames","reservedStrings","rotateStringArray","seed","selfDefending","sourceMapBaseUrl","sourceMapFileName","sourceMapMode","splitStrings","splitStringsChunkLength","stringArray","stringArrayEncoding","stringArrayThreshold","transformObjectKeys","unicodeEscapeSequence","dec","number","AbstractObfuscatingReplacer","AbstractCalleeDataExtractor","AbstractControlFlowReplacer","controlFlowCustomNodeFactory","replacerDataByControlFlowStorageId","identifierDataByControlFlowStorageId","controlFlowStorageId","storageKeysById","controlFlowStorage","replacerId","usingExistingIdentifierChance","getStorageId","getStorageKeysByIdForCurrentStorage","storageKeysForCurrentId","getMathRandom","generateStorageKey","getRandomString","getStorage","storageKey","Factory__IControlFlowCustomNode","AbstractPropertiesExtractor","cachedHostNodesWithStatementsMap","cachedHostStatementsMap","propertyNode","propertyKeyNode","isObjectPatternNode","isArrayPatternNode","isAssignmentPatternNode","isRestElementNode","memberExpressionHostNode","propertiesLength","expressionStatements","removablePropertyIds","propertyValue","isProhibitedPattern","propertyKeyName","getPropertyNodeKeyName","memberExpressionProperty","memberExpressionNode","expressionStatementNode","assignmentExpressionNode","isObjectExpressionNode","transformObjectExpressionNode","objectExpressionNode","filter","extractPropertiesToExpressionStatements","hostStatement","getHostStatement","hostNodeWithStatements","getHostNodeWithStatements","filterExtractedObjectExpressionProperties","insertAfter","AbstractIdentifierNamesGenerator","preservedNames","notReservedName","some","reservedName","exec","DEFAULT_PRESET","config","StringSeparator","CalleeDataExtractor","ControlFlowReplacer","ExpressionWithOperatorControlFlowReplacer","super","leftExpression","rightExpression","controlFlowStorageCallCustomNode","ExpressionWithOperatorControlFlowStorageCallNode","statementNode","getNode","isExpressionStatementNode","DeadCodeInjectionCustomNode","PropertiesExtractor","ObjectExpressionKeysTransformerCustomNode","CustomNodeGroup","LiteralObfuscatingReplacer","ObfuscatingGuard","ConditionalCommentObfuscatingGuard","obfuscationAllowedForCurrentNode","obfuscationAllowedForNextNode","comment","obfuscationEnableCommentRegExp","obfuscationDisableCommentRegExp","isNodeWithComments","checkComments","comments","commentsLength","obfuscationAllowed","MapStorage","storage","storageId","storageValue","size","mergeId","initializable","postConstruct","RandomGenerator","Chance","getRawSeed","min","integer","pool","randomGeneratorPool","string","inputSeed","getInputSeed","getSourceCode","loggingLevelColor","loggingPrefix","loggingMessage","processedMessage","console","colorInfo","LoggingPrefix","Base","colorSuccess","colorWarn","cyan","green","yellow","ContainerModule","ICallsGraphAnalyzer","CallsGraphAnalyzer","IPrevailingKindOfVariablesAnalyzer","PrevailingKindOfVariablesAnalyzer","ICalleeDataExtractor","FunctionDeclarationCalleeDataExtractor","whenTargetNamed","FunctionExpressionCalleeDataExtractor","ObjectExpressionCalleeDataExtractor","Factory__ICalleeDataExtractor","getCacheFactory","calleeDataExtractorFactory","blockScopeBodyLength","lastIndex","limitThresholdActivationIndex","limitThresholdActivationLength","limitIndex","limitThreshold","analyzeRecursive","blockScopeBody","getLimitIndex","blockScopeBodyNode","traverse","isCallExpressionNode","getParentNodeWithStatements","VisitorOption","Skip","analyzeCallExpressionNode","callExpressionNode","calleeDataExtractorsList","calleeDataExtractorName","calleeData","extract","calleeBlockStatement","getCalleeBlockStatement","targetNode","Break","isVariableDeclaratorNode","nextItemInCallsChain","isTargetPropertyNodeWithIdentifierKey","isTargetPropertyNodeWithLiteralKey","objectMembersCallsChain","createObjectMembersCallsChain","functionExpressionName","currentChain","memberExpression","unshift","objectName","shift","findCalleeBlockStatement","objectExpressionProperties","isValidTargetPropertyNode","arrayUtils","prevailingKindOfVariables","defaultKindOfVariables","variableKinds","isVariableDeclarationNode","findMostOccurringElement","IArrayUtils","INodeTransformer","BlockStatementControlFlowTransformer","DeadCodeInjectionTransformer","FunctionControlFlowTransformer","IControlFlowReplacer","BinaryExpressionControlFlowReplacer","CallExpressionControlFlowReplacer","LogicalExpressionControlFlowReplacer","StringLiteralControlFlowReplacer","Factory__IControlFlowReplacer","binaryExpressionNode","binaryExpressionFunctionCustomNode","BinaryExpressionFunctionNode","insertCustomNodeToControlFlowStorage","getControlFlowStorageCallNode","isBreakOrContinueStatement","isVariableDeclarationWithLetOrConstKind","isClassDeclaration","isClassDeclarationNode","blockStatementNode","canTransform","isWhileStatementNode","isProhibitedStatementNode","transformationStage","ControlFlowFlattening","leave","transformNode","canTransformBlockStatementNode","blockStatementBody","originalKeys","createWithRange","shuffledKeys","shuffle","originalKeysIndexesInShuffledArray","blockStatementControlFlowFlatteningCustomNode","BlockStatementControlFlowFlatteningNode","newBlockStatementNode","String","callExpressionFunctionCustomNode","CallExpressionFunctionNode","expressionArguments","CallExpressionControlFlowStorageCallNode","deadCodeInjectionCustomNodeFactory","transformersRunner","deadCodeInjectionRootAstHostNodeSet","collectedBlockStatements","collectedBlockStatementsTotalLength","isAwaitExpressionNode","isSuperNode","slicedBody","hostBlockStatementNode","functionDeclarationName","isScopeHoistedFunctionDeclaration","nestedBlockStatementsCount","isValidBlockStatementNode","maxNestedBlockStatementsCount","isProhibitedNodeInsideCollectedBlockStatement","isScopeHoistingFunctionDeclaration","DeadCodeInjection","analyzeNode","Finalizing","isDeadCodeInjectionRootAstHostNode","restoreNode","programNode","clonedBlockStatementNode","clone","isValidCollectedBlockStatementNode","transformedBlockStatementNode","makeClonedBlockStatementNodeUnique","minCollectedBlockStatementsCount","isValidWrappedBlockStatementNode","maxInteger","randomIndex","randomBlockStatementNode","splice","replaceBlockStatementNode","deadCodeInjectionRootAstHostNode","hostNodeFirstStatement","hostNode","functionExpressionNode","transform","transformersToRenameBlockScopeIdentifiers","Obfuscating","functionDeclarationNode","deadCodeInjectionRootAstHostNodeName","blockStatementDeadCodeInjectionCustomNode","BlockStatementDeadCodeInjectionNode","CatchClauseTransformer","ClassDeclarationTransformer","FunctionDeclarationTransformer","FunctionTransformer","LabeledStatementTransformer","VariableDeclarationTransformer","Factory__IDeadCodeInjectionCustomNode","controlFlowStorageFactory","controlFlowReplacerFactory","controlFlowData","visitedFunctionNodes","hostNodesWithControlFlowNode","functionNode","getHostNode","getControlFlowStorage","transformFunctionBody","getLength","controlFlowStorageCustomNode","ControlFlowStorageNode","hostControlFlowStorage","mergeWith","functionNodeBody","blockScopesOfNode","getParentNodesWithStatements","pop","hostNodeSearchMinDepth","hostNodeSearchMaxDepth","isIgnoredNode","isVisitedFunctionNode","controlFlowReplacersMap","controlFlowReplacerName","Factory__TControlFlowStorage","logicalExpressionNode","checkForProhibitedExpressions","logicalExpressionFunctionCustomNode","LogicalExpressionFunctionNode","expressionNode","nodeForCheck","literalFunctionCustomNode","StringLiteralNode","StringLiteralControlFlowStorageCallNode","MemberExpressionTransformer","MethodDefinitionTransformer","ObjectExpressionKeysTransformer","ObjectExpressionTransformer","SplitStringTransformer","TemplateLiteralTransformer","IPropertiesExtractor","AssignmentExpressionPropertiesExtractor","BasePropertiesExtractor","VariableDeclaratorPropertiesExtractor","Factory__IPropertiesExtractor","isIfStatementNode","isForStatementTypeNode","hostParentNode","leftNode","isProhibitedHostParent","objectExpressionKeysTransformerCustomNodeFactory","newObjectExpressionHostNode","getObjectExpressionHostNode","newObjectExpressionIdentifier","getObjectExpressionIdentifierNode","statementsToInsert","insertBefore","objectExpressionHostCustomNode","BasePropertiesExtractorObjectExpressionHostNode","objectExpressionHostNode","newObjectExpressionIdentifierNode","Factory__IObjectExpressionKeysTransformerCustomNode","Converting","methodDefinitionNode","replaceIdentifierKey","replaceLiteralKey","keyNode","ignoredNames","propertiesExtractorFactory","transformNodeWithBaseExtractor","propertiesExtractorName","propertiesExtractorsMap","escapeSequenceEncoder","transformComputedProperty","transformBaseProperty","getPropertyKeyValue","inputValue","encode","IEscapeSequenceEncoder","runAfter","chunkSize","chunksCount","ceil","chunks","nextChunkStartIndex","chunkIndex","substr","stringChunks","chunkString","transformStringChunksToBinaryExpressionNode","lastChunk","lastChunkLiteralNode","isTemplateLiteralNode","isTaggedTemplateExpressionNode","isValidTemplateLiteralNode","templateLiteralNode","templateLiteralExpressions","expressions","transformedNode","nodes","quasis","templateElement","cooked","isLiteralNodeWithStringValue","root","isProhibitedObjectExpressionNode","variableDeclaratorNode","hostVariableDeclarator","getHostVariableDeclaratorNode","hostVariableDeclaration","getHostVariableDeclarationNode","indexOfDeclarator","declaratorsAfterCurrentDeclarator","variableDeclarator","ICustomNode","ConsoleOutputDisableExpressionNode","DebugProtectionFunctionCallNode","DebugProtectionFunctionIntervalNode","DebugProtectionFunctionNode","DomainLockNode","NodeCallsControllerFunctionNode","SelfDefendingUnicodeNode","StringArrayCallsWrapper","StringArrayNode","StringArrayRotateFunctionNode","Newable__ICustomNode","toConstructor","ICustomNodeGroup","ConsoleOutputCustomNodeGroup","DebugProtectionCustomNodeGroup","DomainLockCustomNodeGroup","SelfDefendingCustomNodeGroup","StringArrayCustomNodeGroup","Factory__ICustomNode","getFactory","getConstructorFactory","Factory__ICustomNodeGroup","CustomNodeFormatter","customNodeFactory","BeforeObfuscation","randomCallsGraphIndex","getRandomCallsGraphIndex","appendCustomNodeIfExist","appendToOptimalBlockScope","targetNodeWithStatements","callsControllerFunctionName","consoleOutputDisableExpressionNode","nodeCallsControllerFunctionNode","append","programBodyLength","debugProtectionFunctionName","debugProtectionFunctionNode","debugProtectionFunctionCallNode","debugProtectionFunctionIntervalNode","domainLockNode","AfterObfuscation","selfDefendingUnicodeNode","stringArrayStorage","stringArrayNode","stringArrayCallsWrapper","stringArrayRotateFunctionNode","stringArrayStorageId","stringArrayName","stringArrayCallsWrapperName","stringArrayRotateValue","TStringArrayStorage","variableDeclarationNode","returnStatementNode","controllerIdentifierName","indexIdentifierName","join","whileStatementNode","switchStatementNode","updateExpressionNode","isReturnStatementNode","continueStatement","switchCaseNode","breakStatement","random1","random2","leftString","rightString","ifStatementNode","controlFlowStorageName","controlFlowStorageKey","calleeIdentifier","argumentsLength","propertyNodes","from","convertCodeToStructure","globalVariableTemplate","getGlobalVariableTemplate","GlobalVariableNoEvalTemplate","formatTemplate","ConsoleOutputDisableExpressionTemplate","consoleLogDisableFunctionName","singleNodeCallControllerFunctionName","prevailingKindOfVariablesAnalyzer","getPrevailingKind","template","mapping","DebugProtectionFunctionCallTemplate","DebugProtectionFunctionIntervalTemplate","debuggerTemplate","DebuggerTemplate","DebuggerTemplateNoEval","DebugProtectionFunctionTemplate","cryptUtils","domainsString","hiddenDomainsString","diff","hideString","DomainLockNodeTemplate","domainLockFunctionName","domains","ICryptUtils","leftValue","rightValue","SingleNodeCallControllerTemplate","getObfuscatedCode","SelfDefendingTemplate","selfDefendingFunctionName","decodeNodeTemplate","getDecodeStringArrayTemplate","StringArrayCallsWrapperTemplate","atobPolyfill","AtobTemplate","decodeStringArrayTemplate","selfDefendingCode","StringArrayRc4DecodeNodeTemplate","rc4Polyfill","Rc4Template","StringArrayBase64DecodeNodeTemplate","rc4BytesIdentifier","statesIdentifier","newStateIdentifier","firstStateIdentifier","secondStateIdentifier","checkStateIdentifier","runStateIdentifier","getStateIdentifier","stateResultIdentifier","initializedIdentifier","base64DecodeFunctionIdentifier","dataIdentifier","rc4Identifier","onceIdentifier","rotateArray","StringArrayTemplate","timesName","whileFunctionName","StringArrayRotateFunctionTemplate","NumberUtils","toHex","literalValue","IIdentifierNamesGenerator","cachedIdentifierNamesGenerator","identifierNameGeneratorFactory","identifierNamesSet","getInitialIdentifierNames","identifiersIterator","values","identifierName","newIdentifierName","isSuccess","character","toUpperCase","toLowerCase","iteratorResult","next","done","getIncrementedIdentifierNames","identifierNames","formattedIdentifierNames","incrementIdentifierName","randomVariableNameSet","nameLength","randomInteger","hexadecimalNumber","prefixLength","baseNameLength","baseIdentifierNameLength","baseIdentifierName","previousMangledName","initMangledNameCharacter","generateNewMangledName","mangledName","isValidIdentifierName","newMangledName","nameSequence","zeroSequence","num","repeat","charAt","indexInSequence","substring","Factory__INodeTransformer","ImportDeclarationTransformer","LiteralTransformer","IObfuscatingReplacer","BooleanLiteralObfuscatingReplacer","NumberLiteralObfuscatingReplacer","StringLiteralObfuscatingReplacer","IIdentifierObfuscatingReplacer","BaseIdentifierObfuscatingReplacer","Factory__IObfuscatingReplacer","Factory__IIdentifierObfuscatingReplacer","blockScopesMap","nodeValue","lexicalScopeNode","namesMap","nodeName","isReservedName","generateWithPrefix","preserveName","getFalseUnaryExpressionNode","arrayExpressionNode","getTrueUnaryExpressionNode","identifierObfuscatingReplacerFactory","identifierObfuscatingReplacer","isCatchClauseNode","catchClauseNode","getLexicalScope","storeCatchClauseParam","replaceCatchClauseParam","param","storeLocalName","isReplaceableIdentifierNode","renamedIdentifier","replaceableIdentifiers","isExportNamedDeclarationNode","classDeclarationNode","isGlobalDeclaration","storeClassName","replaceScopeCachedIdentifiers","replaceScopeIdentifiers","storeGlobalName","cachedReplaceableIdentifiers","cachedReplaceableIdentifierLength","replaceableIdentifier","newReplaceableIdentifier","storedReplaceableIdentifiersNamesMap","isRenamedIdentifier","storedReplaceableIdentifiers","storeFunctionName","storeFunctionParams","replaceFunctionParams","getLexicalScopes","visitor","isProhibitedIdentifierOfPropertyNode","paramsNode","ignoredIdentifierNamesSet","isProhibitedIdentifierOfShorthandPropertyNode","isGlobalFunctionDeclarationIdentifier","importSpecifierNode","isImportSpecifierNode","imported","local","isImportDeclarationNode","importDeclarationNode","storeImportSpecifierNames","specifiers","isProhibitedImportSpecifierNode","labeledStatementNode","storeLabeledStatementName","replaceLabeledStatementName","newIdentifier","literalObfuscatingReplacerFactory","isReplacedLiteral","isProhibitedNode","newLiteralNode","numberLiteralCache","rawValue","isCeil","nodesCache","stringLiteralHexadecimalIndexCache","rc4Keys","rc4KeyLength","rc4KeysCount","hexadecimalIndex","hexadecimalLiteralNode","replacedLiteral","rc4KeyLiteralNode","useStringArray","canUseStringArray","cacheKey","resultNode","replaceWithStringArrayCallNode","replaceWithLiteralNode","minimumLengthForStringArray","stringArrayStorageLength","fromCache","hexadecimalRawIndex","encodedValue","btoa","rc4","getEncodedValue","escapedValue","stringArrayStorageCallsWrapperName","getStringArrayHexadecimalIndex","callExpressionArgs","getHexadecimalLiteralNode","getRc4KeyLiteralNode","stringArrayIdentifierNode","lexicalScopesWithObjectPatternWithoutDeclarationMap","NodeBlockLexicalScopeUtils","storeVariableNames","traverseDeclarationIdentifiers","isProhibitedVariableName","hostVariableDeclarationNode","isProhibitedVariableNameUsedInObjectPatternNode","isLexicalScopeHasObjectPatternWithoutDeclaration","isProhibitedVariableDeclaration","isAssignmentExpressionNode","cachedReplaceableIdentifiersNamesMap","isNodeWithBlockLexicalScope","Options","IOptionsNormalizer","OptionsNormalizer","optionsNormalizer","errors","validateSync","validatorOptions","ValidationErrorsFormatter","format","normalize","validationError","IsBoolean","IsNumber","Min","Max","IsArray","ArrayUnique","IsString","each","IsIn","ValidateIf","ArrayNotEmpty","IsUrl","require_protocol","require_tld","require_valid_protocol","errorMessages","error","formatWithNestedConstraints","constraints","constraint","normalizedOptions","normalizerRule","normalizerRules","ControlFlowFlatteningThresholdRule","DeadCodeInjectionRule","DeadCodeInjectionThresholdRule","DomainLockRule","InputFileNameRule","SeedRule","SelfDefendingRule","SourceMapBaseUrlRule","SourceMapFileNameRule","SplitStringsChunkLengthRule","StringArrayRule","StringArrayEncodingRule","StringArrayThresholdRule","normalizedDomains","extractDomainFrom","Dot","floor","random","endsWith","sourceMapFileNameParts","sourceMapFileNamePartsCount","lastPart","CommentsTransformer","CustomNodesTransformer","EvalCallExpressionTransformer","MetadataTransformer","ObfuscatingGuardsTransformer","ParentificationTransformer","INodeGuard","BlackListObfuscatingGuard","ReservedStringObfuscatingGuard","Factory__INodeGuard","VariablePreserveTransformer","blackListGuardsLength","blackListGuards","isUseStrictOperator","Initializing","rootNode","transformComments","commentIdx","findIndex","range","reverse","preservedWords","preservedWord","isConditionalComment","callsGraphAnalyzer","obfuscationEventEmitter","customNodeGroupStorage","Preparing","appendCustomNodesBeforeObfuscation","appendCustomNodesAfterObfuscation","analyze","customNodeGroup","once","getAppendEvent","appendCustomNodes","emit","TCustomNodeGroupStorage","evalRootAstHostNodeSet","extractEvalStringFromLiteralNode","extractEvalStringFromTemplateLiteralNode","isEvalRootAstHostNode","callExpressionFirstArgument","evalString","extractEvalStringFromCallExpressionArgument","ast","evalRootAstHostNode","targetAst","convertStructureToCode","obfuscatingGuardFactory","obfuscatingGuards","obfuscatingGuardsList","every","nodeGuard","check","isReservedString","reservedString","CustomNodeGroupStorage","StringArrayStorage","Newable__TControlFlowStorage","ControlFlowStorage","customNodeGroupFactory","customNodeGroupsList","customNodeGroupName","ArrayStorage","baseStringArrayName","stringArrayNameLength","baseStringArrayCallsWrapperName","rotationValue","rotate","storageLength","ArrayUtils","CryptUtils","EscapeSequenceEncoder","ILevelledTopologicalSorter","LevelledTopologicalSorter","INodeTransformerNamesGroupsBuilder","NodeTransformerNamesGroupsBuilder","array","elementsMap","mostOccurringElement","mostOccurringElementCount","element","updatedElementCount","times","newArray","temp","shuffledArray","j","output","encodeURIComponent","match","p1","fromCharCode","parseInt","block","charCode","idx","charCodeAt","str","randomStringDiff","randomStringDiffArray","s1","s2","i1","i2","randomMerge","x","y","stringsCache","encodeAllSymbols","replaceRegExp","escapeSequenceRegExp","regExp","graph","precedent","link","register","consequents","results","marks","visit","sort","resultItemsGroups","hasNodes","rootNodes","findRootNodes","delete","getPrecedents","precedentsGroups","precedentsGroup","hasPrecedents","precedents","mark","levelledTopologicalSorter","normalizedNodeTransformers","nodeTransformerNames","relationEdges","buildNodeTransformersRelationEdges","sortByGroups","nodeTransformerName","runAfterRelations","runAfterRelation","obfuscatedCodeFactory","logger","timeStart","Date","now","info","LoggingMessage","Version","ObfuscationStarted","RandomGeneratorSeed","parseCode","obfuscatedAstTree","transformAstTree","generatorOutput","generateCode","obfuscationTime","success","ObfuscationCompleted","EspreeFacade","espreeParseOptions","runTransformationStage","warn","EmptySourceCode","escodegenParams","sourceContent","transformersList","loc","verbatim","input","sourceTypeLength","sourceTypes","parseType","processParsingError","message","line","lineNumber","column","inputConfig","errorMessage","position","errorLine","startErrorIndex","nearestSymbolsCount","endErrorIndex","formattedPointer","colorError","formattedCodeSlice","red","decorate","correctObfuscatedCode","sourceMapUrl","sourceMappingUrl","nodeTransformerFactory","nodeTransformerNamesGroupsBuilder","cachedNodeTransformersData","nodeTransformerNamesGroups","buildNormalizedNodeTransformers","build","nodeTransformerNamesGroup","enterVisitors","leaveVisitors","getVisitor","mergeVisitorsForDirection","VisitorDirection","Enter","Leave","acc","visitors","direction","visitorsLength","visitorFunction","visitorResult","isNode"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 205);\n","module.exports = require(\"inversify\");","module.exports = require(\"tslib\");","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscatedCode = 'Factory<IObfuscatedCode>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__IObjectExpressionKeysTransformerCustomNode = 'Factory<IObjectExpressionKeysTransformerCustomNode>',\n    Factory__IPropertiesExtractor = 'Factory<IPropertiesExtractor>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICallsGraphAnalyzer = 'ICallsGraphAnalyzer',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    ICustomNodeFormatter = 'ICustomNodeFormatter',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILevelledTopologicalSorter = 'ILevelledTopologicalSorter',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    INodeTransformerNamesGroupsBuilder = 'INodeTransformerNamesGroupsBuilder',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscatedCode = 'IObfuscatedCode',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IPrevailingKindOfVariablesAnalyzer = 'IPrevailingKindOfVariablesAnalyzer',\n    IPropertiesExtractor = 'IPropertiesExtractor',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithLexicalStatements: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentExpressionNode (node: ESTree.Node): node is ESTree.AssignmentExpression {\n        return node.type === NodeType.AssignmentExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (\n        node: ESTree.Node\n    ): node is ESTree.ClassDeclaration & { id: ESTree.Identifier } {\n        return node.type === NodeType.ClassDeclaration && node.id !== null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isDirectiveNode (node: ESTree.Node): node is ESTree.Directive {\n        return node.type === NodeType.ExpressionStatement\n            && 'directive' in node;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExportNamedDeclarationNode (node: ESTree.Node): node is ESTree.ExportNamedDeclaration {\n        return node.type === NodeType.ExportNamedDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement\n            && !('directive' in node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForStatementTypeNode (\n        node: ESTree.Node\n    ): node is ESTree.ForStatement | ESTree.ForInStatement | ESTree.ForOfStatement {\n        return NodeGuards.isForStatementNode(node)\n            || NodeGuards.isForInStatementNode(node)\n            || NodeGuards.isForOfStatementNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForStatementNode (node: ESTree.Node): node is ESTree.ForStatement {\n        return node.type === NodeType.ForStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForInStatementNode (node: ESTree.Node): node is ESTree.ForInStatement {\n        return node.type === NodeType.ForInStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForOfStatementNode (node: ESTree.Node): node is ESTree.ForOfStatement {\n        return node.type === NodeType.ForOfStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionNode (node: ESTree.Node): node is ESTree.Function {\n        return NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (\n        node: ESTree.Node\n    ): node is ESTree.FunctionDeclaration & { id: ESTree.Identifier } {\n        return node.type === NodeType.FunctionDeclaration && node.id !== null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIfStatementNode (node: ESTree.Node): node is ESTree.IfStatement {\n        return node.type === NodeType.IfStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDeclarationNode (node: ESTree.Node): node is ESTree.ImportDeclaration {\n        return node.type === NodeType.ImportDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportSpecifierNode (node: ESTree.Node): node is ESTree.ImportSpecifier {\n        return node.type === NodeType.ImportSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isProgramNode(node) || NodeGuards.isFunctionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithBlockLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isNodeWithLexicalScope(node) || NodeGuards.isBlockStatementNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScopeStatements (\n        node: ESTree.Node,\n        parentNode: ESTree.Node\n    ): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || (NodeGuards.isBlockStatementNode(node) && NodeGuards.nodesWithLexicalStatements.includes(parentNode.type));\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithStatements (node: ESTree.Node): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsPropertyNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isPropertyNode(parentNode)\n            && !parentNode.computed\n            && parentNode.key === node;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsMemberExpressionNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return (\n            NodeGuards.isMemberExpressionNode(parentNode)\n            && !parentNode.computed\n            && parentNode.property === node\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsMethodDefinitionNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isMethodDefinitionNode(parentNode)\n            && !parentNode.computed;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isIdentifierNode(node)\n            && !NodeGuards.parentNodeIsPropertyNode(node, parentNode)\n            && !NodeGuards.parentNodeIsMemberExpressionNode(node, parentNode)\n            && !NodeGuards.parentNodeIsMethodDefinitionNode(node, parentNode)\n            && !NodeGuards.isLabelIdentifierNode(node, parentNode);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTaggedTemplateExpressionNode (node: ESTree.Node): node is ESTree.TaggedTemplateExpression {\n        return node.type === NodeType.TaggedTemplateExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.Directive {\n        return NodeGuards.isDirectiveNode(node)\n            && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: IInitializable[keyof IInitializable] = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): typeof originalMethod {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: typeof originalMethod = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey.toString()}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey.toString()}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n","import * as escodegen from 'escodegen';\nimport * as espree from 'espree';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { NodeGuards } from './NodeGuards';\nimport { NodeMetadata } from './NodeMetadata';\n\nexport class NodeUtils {\n    /**\n     * @param {T} literalNode\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyTo (literalNode: ESTree.Literal): ESTree.Literal {\n        literalNode['x-verbatim-property'] = {\n            content: literalNode.raw,\n            precedence: escodegen.Precedence.Primary\n        };\n\n        return literalNode;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentizeAst(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {Statement[]}\n     */\n    public static convertCodeToStructure (code: string): ESTree.Statement[] {\n        const structure: ESTree.Program = espree.parse(code, {\n            ecmaVersion: 10,\n            sourceType: 'script'\n        });\n\n        estraverse.replace(structure, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node => {\n                NodeUtils.parentizeNode(node, parentNode);\n\n                if (NodeGuards.isLiteralNode(node)) {\n                    NodeUtils.addXVerbatimPropertyTo(node);\n                }\n\n                NodeMetadata.set(node, { ignoredNode: false });\n\n                return node;\n            }\n        });\n\n        return <ESTree.Statement[]>structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentizeAst <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: Partial<T> = {};\n        const nodeKeys: (keyof T)[] = <(keyof T)[]>Object.keys(node);\n\n        nodeKeys\n            .forEach((property: keyof T) => {\n                if (property === 'parentNode') {\n                    return;\n                }\n\n                const value: T[keyof T] = node[property];\n\n                let clonedValue: T[keyof T] | T[keyof T][] | null;\n\n                if (value === null || value instanceof RegExp) {\n                    clonedValue = value;\n                } else if (Array.isArray(value)) {\n                    clonedValue = value.map(NodeUtils.cloneRecursive);\n                } else if (typeof value === 'object') {\n                    clonedValue = NodeUtils.cloneRecursive(value);\n                } else {\n                    clonedValue = value;\n                }\n\n                copy[property] = <T[keyof T]>clonedValue;\n            });\n\n        return <T>copy;\n    }\n}\n","export enum TransformationStage {\n    Initializing = 'Initializing',\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer {\n    /**\n     * @type {NodeTransformer[] | undefined}\n     */\n    public readonly runAfter: NodeTransformer[] | undefined;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n","/* tslint:disable:max-file-line-count */\n\nimport * as escodegen from 'escodegen';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeFactory {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static programNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static arrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static assignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static binaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static blockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static breakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        return {\n            type: NodeType.BreakStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static callExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static continueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        return {\n            type: NodeType.ContinueStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Literal} expression\n     * @param {string} directive\n     * @returns {Directive}\n     */\n    public static directiveNode (\n        expression: ESTree.Literal,\n        directive: string\n    ): ESTree.Directive {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            directive,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static expressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static functionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: NodeFactory.identifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static functionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static ifStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static identifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static literalNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static logicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static memberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static methodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static objectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static propertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static returnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static switchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static switchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static unaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static updateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static variableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static variableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static whileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode <\n    TInitialData extends any[] = any[]\n> implements ICustomNode <TInitialData> {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ICustomNodeFormatter}\n     */\n    protected readonly customNodeFormatter: ICustomNodeFormatter;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    protected constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.customNodeFormatter = customNodeFormatter;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TInitialData} args\n     */\n    public abstract initialize (...args: TInitialData): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            const nodeTemplate: string = this.getNodeTemplate();\n\n            this.cachedNode = this.customNodeFormatter.formatStructure(\n                this.getNodeStructure(nodeTemplate)\n            );\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (nodeTemplate: string): TStatement[];\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return '';\n    }\n}\n","module.exports = require(\"estraverse\");","import * as ESTree from 'estree';\n\nexport class NodeMetadata {\n    /**\n     * @param {T} node\n     * @param {Partial<T[\"metadata\"]>} metadata\n     */\n    public static set <T extends ESTree.Node = ESTree.Node> (node: T, metadata: Partial<T['metadata']>): void {\n        node.metadata = Object.assign(node.metadata || {}, metadata);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {keyof T} metadataKey\n     * @returns {T[keyof T] | undefined}\n     */\n    public static get <T extends ESTree.BaseNodeMetadata> (node: ESTree.Node, metadataKey: keyof T): T[keyof T] | undefined {\n        return node.metadata !== undefined\n            ? (<T>node.metadata)[metadataKey]\n            : undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIgnoredNode (node: ESTree.Node): boolean {\n        return NodeMetadata.get(node, 'ignoredNode') === true;\n    }\n\n    /**\n     * @param {Node} identifierNode\n     * @returns {boolean}\n     */\n    public static isRenamedIdentifier (identifierNode: ESTree.Identifier): boolean {\n        return NodeMetadata.get<ESTree.IdentifierNodeMetadata>(identifierNode, 'renamedIdentifier') === true;\n    }\n\n    /**\n     * @param {Node} literalNode\n     * @returns {boolean}\n     */\n    public static isReplacedLiteral (literalNode: ESTree.Literal): boolean {\n        return NodeMetadata.get<ESTree.LiteralNodeMetadata>(literalNode, 'replacedLiteral') === true;\n    }\n}\n","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExportNamedDeclaration = 'ExportNamedDeclaration',\n    ExpressionStatement = 'ExpressionStatement',\n    ForStatement = 'ForStatement',\n    ForInStatement = 'ForInStatement',\n    ForOfStatement = 'ForOfStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    ImportDeclaration = 'ImportDeclaration',\n    ImportDefaultSpecifier = 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier = 'ImportNamespaceSpecifier',\n    ImportSpecifier = 'ImportSpecifier',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TaggedTemplateExpression = 'TaggedTemplateExpression',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscatedCode } from '../source-code/ObfuscatedCode';\nimport { SourceCode } from '../source-code/SourceCode';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, sourceMap: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode, sourceMap))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode)\n            .to(ObfuscatedCode);\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.Factory__IObfuscatedCode)\n            .toFactory<IObfuscatedCode>((context: interfaces.Context) => {\n                return (obfuscatedCodeAsString: string, sourceMapAsString: string) => {\n                    const obfuscatedCode: IObfuscatedCode = context.container\n                        .get<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode);\n\n                    obfuscatedCode.initialize(obfuscatedCodeAsString, sourceMapAsString);\n\n                    return obfuscatedCode;\n                };\n            });\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICallsGraphData } from '../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static append (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n            ...statements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {ICallsGraphData[]} callsGraphData\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} bodyStatements\n     * @param {number} index\n     */\n    public static appendToOptimalBlockScope (\n        callsGraphData: ICallsGraphData[],\n        nodeWithStatements: TNodeWithStatements,\n        bodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        const targetBlockScope: TNodeWithStatements = callsGraphData.length\n            ? NodeAppender.getOptimalBlockScope(callsGraphData, index)\n            : nodeWithStatements;\n\n        NodeAppender.prepend(targetBlockScope, bodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {ICallsGraphData[]} callsGraphData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        callsGraphData: ICallsGraphData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: ICallsGraphData = callsGraphData[index];\n\n        if (deep <= 0) {\n            throw new Error('Invalid `deep` argument value. Value should be bigger then 0.');\n        }\n\n        if (deep > 1 && firstCall.callsGraph.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.callsGraph, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertBefore (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(nodeWithStatements)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(nodeWithStatements, statements, indexInScopeStatement);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertAfter (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(nodeWithStatements)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(nodeWithStatements, statements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {number} index\n     */\n    public static insertAtIndex (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        index: number\n    ): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(0, index),\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static prepend (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @returns {TStatement[]}\n     */\n    private static getScopeStatements (nodeWithStatements: TNodeWithStatements): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            return nodeWithStatements.consequent;\n        }\n\n        return nodeWithStatements.body;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[]\n    ): TStatement[] {\n        statements.forEach((statement: TStatement) => {\n            statement.parentNode = nodeWithStatements;\n        });\n\n        return statements;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    private static setScopeStatements (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            nodeWithStatements.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        nodeWithStatements.body = statements;\n    }\n}\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const ObfuscationTarget: Readonly<{\n    Browser: 'browser';\n    BrowserNoEval: 'browser-no-eval';\n    Node: 'node';\n}> = MakeEnum({\n    Browser: 'browser',\n    BrowserNoEval: 'browser-no-eval',\n    Node: 'node'\n});\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeStatementUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getParentNodeWithStatements (node: ESTree.Node): TNodeWithStatements {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements[]}\n     */\n    public static getParentNodesWithStatements (node: ESTree.Node): TNodeWithStatements[] {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, 1);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, -1);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {Statement}\n     */\n    public static getRootStatementOfNode (node: ESTree.Node): ESTree.Statement {\n        if (NodeGuards.isProgramNode(node)) {\n            throw new Error('Unable to find root statement for `Program` node');\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getRootStatementOfNode(parentNode);\n        }\n\n        return <ESTree.Statement>node;\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithStatements {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithStatements[]} nodesWithStatements\n     * @param {number} depth\n     * @returns {TNodeWithStatements[]}\n     */\n    private static getParentNodesWithStatementsRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithStatements: TNodeWithStatements[] = [],\n        depth: number = 0\n    ): TNodeWithStatements[] {\n        if (nodesWithStatements.length >= maxSize) {\n            return nodesWithStatements;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            (NodeGuards.isNodeWithLexicalScopeStatements(node, parentNode) && depth > 0)\n        ) {\n            nodesWithStatements.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeStatementUtils.getParentNodesWithStatementsRecursive(parentNode, maxSize, nodesWithStatements, ++depth);\n        }\n\n        return nodesWithStatements;\n    }\n\n    /**\n     * @param {Statement} statement\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementByOffset (statement: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(statement);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(statement);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    ClassDeclarationTransformer = 'ClassDeclarationTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    CatchClauseTransformer = 'CatchClauseTransformer',\n    FunctionDeclarationTransformer = 'FunctionDeclarationTransformer',\n    FunctionTransformer = 'FunctionTransformer',\n    ImportDeclarationTransformer = 'ImportDeclarationTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MetadataTransformer = 'MetadataTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    SplitStringTransformer = 'SplitStringTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariableDeclarationTransformer = 'VariableDeclarationTransformer',\n    VariablePreserveTransformer = 'VariablePreserveTransformer',\n}\n","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @type {string | undefined}\n     */\n    public static version: string = process.env.VERSION || 'unknown';\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscatedCode}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscatedCode {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, '', inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscatedCode: IObfuscatedCode = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscatedCode;\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public abstract appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} callsGraphLength\n     * @returns {number}\n     */\n    protected getRandomCallsGraphIndex (callsGraphLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(callsGraphLength - 1)));\n    }\n}\n","export class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFrom (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n}\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const IdentifierNamesGenerator: Readonly<{\n    DictionaryIdentifierNamesGenerator: 'dictionary';\n    HexadecimalIdentifierNamesGenerator: 'hexadecimal';\n    MangledIdentifierNamesGenerator: 'mangled';\n}> = MakeEnum({\n    DictionaryIdentifierNamesGenerator: 'dictionary',\n    HexadecimalIdentifierNamesGenerator: 'hexadecimal',\n    MangledIdentifierNamesGenerator: 'mangled'\n});\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const SourceMapMode: Readonly<{\n    Inline: 'inline';\n    Separate: 'separate';\n}> = MakeEnum({\n    Inline: 'inline',\n    Separate: 'separate'\n});\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const StringArrayEncoding: Readonly<{\n    Base64: 'base64';\n    Rc4: 'rc4';\n}> = MakeEnum({\n    Base64: 'base64',\n    Rc4: 'rc4'\n});\n","module.exports = require(\"@gradecam/tsenum\");","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    identifiersDictionary: [],\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    splitStrings: false,\n    splitStringsChunkLength: 0,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","export class NumberUtils {\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static toHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeil (number: number): boolean {\n        return number % 1 === 0;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../../../types/node/TNodeWithLexicalScope';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {SimpleLiteral[\"value\"]} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Node}\n     */\n    public abstract replace (nodeValue: ESTree.SimpleLiteral['value'], lexicalScopeNode?: TNodeWithLexicalScope): ESTree.Node;\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: TControlFlowStorage): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: TControlFlowStorage,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n","module.exports = require(\"escodegen\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport abstract class AbstractPropertiesExtractor implements IPropertiesExtractor {\n    /**\n     * @type {Map<ESTree.ObjectExpression, TNodeWithStatements>}\n     */\n    protected readonly cachedHostNodesWithStatementsMap: Map <ESTree.ObjectExpression, TNodeWithStatements> = new Map();\n\n    /**\n     * @type {Map<ESTree.ObjectExpression, ESTree.Statement>}\n     */\n    protected readonly cachedHostStatementsMap: Map <ESTree.ObjectExpression, ESTree.Statement> = new Map();\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    protected static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        if (!propertyNode.key) {\n            return null;\n        }\n\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (NodeGuards.isLiteralNode(propertyKeyNode) && typeof propertyKeyNode.value === 'string') {\n            return propertyKeyNode.value;\n        }\n\n        if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedPattern (node: ESTree.Node): node is ESTree.Pattern {\n        return !node\n            || NodeGuards.isObjectPatternNode(node)\n            || NodeGuards.isArrayPatternNode(node)\n            || NodeGuards.isAssignmentPatternNode(node)\n            || NodeGuards.isRestElementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} hostNode\n     * @returns {Node}\n     */\n    public abstract extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.Node\n    ): ESTree.Node;\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionHostNode\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    protected extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionHostNode: ESTree.Expression\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (AbstractPropertiesExtractor.isProhibitedPattern(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = AbstractPropertiesExtractor.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && !!property.key && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? NodeFactory.literalNode(propertyKeyName)\n                : NodeFactory.identifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = NodeFactory\n                .memberExpressionNode(memberExpressionHostNode, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = NodeFactory.expressionStatementNode(\n                NodeFactory.assignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {number[]} removablePropertyIds\n     */\n    protected filterExtractedObjectExpressionProperties (\n        objectExpressionNode: ESTree.ObjectExpression,\n        removablePropertyIds: number[]\n    ): void {\n        objectExpressionNode.properties = objectExpressionNode.properties\n            .filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionHostNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Expression\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionHostNode);\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const hostNodeWithStatements: TNodeWithStatements = this.getHostNodeWithStatements(\n            objectExpressionNode,\n            hostStatement\n        );\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertAfter(hostNodeWithStatements, expressionStatements, hostStatement);\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Statement} hostStatement\n     * @returns {TNodeWithStatements}\n     */\n    protected getHostNodeWithStatements (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostStatement: ESTree.Statement\n    ): TNodeWithStatements {\n        if (this.cachedHostNodesWithStatementsMap.has(objectExpressionNode)) {\n            return <TNodeWithStatements>this.cachedHostNodesWithStatementsMap.get(objectExpressionNode);\n        }\n\n        const nodeWithStatements: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(hostStatement);\n\n        this.cachedHostNodesWithStatementsMap.set(objectExpressionNode, nodeWithStatements);\n\n        return nodeWithStatements;\n    }\n\n    /**\n     * Returns host statement of object expression node\n     *\n     * @param {NodeGuards} objectExpressionNode\n     * @returns {Node}\n     */\n    protected getHostStatement (objectExpressionNode: ESTree.ObjectExpression): ESTree.Statement {\n        if (this.cachedHostStatementsMap.has(objectExpressionNode)) {\n            return <ESTree.Statement>this.cachedHostStatementsMap.get(objectExpressionNode);\n        }\n\n        const hostStatement: ESTree.Statement = NodeStatementUtils.getRootStatementOfNode(objectExpressionNode);\n\n        this.cachedHostStatementsMap.set(objectExpressionNode, hostStatement);\n\n        return hostStatement;\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        const that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Array}\n     */\n    protected readonly preservedNames: string[] = [];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generate (nameLength?: number): string;\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (nameLength?: number): string;\n\n    /**\n     * @param {string} name\n     * @returns {void}\n     */\n    public preserveName (name: string): void {\n        this.preservedNames.push(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (name: string): boolean {\n        return this.notReservedName(name) && !this.preservedNames.includes(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private notReservedName (name: string): boolean {\n        return this.options.reservedNames.length\n            ? !this.options.reservedNames.some((reservedName: string) =>\n                new RegExp(reservedName, 'g').exec(name) !== null\n            )\n            : true;\n\n    }\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    identifiersDictionary: [],\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    splitStrings: false,\n    splitStringsChunkLength: 10,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","export enum StringSeparator {\n    Dot = '.'\n}\n","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode<TInitialData<ExpressionWithOperatorControlFlowStorageCallNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","module.exports = require(\"espree\");","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n","export enum PropertiesExtractor {\n    AssignmentExpressionPropertiesExtractor = 'AssignmentExpressionPropertiesExtractor',\n    BasePropertiesExtractor = 'BasePropertiesExtractor',\n    VariableDeclaratorPropertiesExtractor = 'VariableDeclaratorPropertiesExtractor'\n}\n","export enum ObjectExpressionKeysTransformerCustomNode {\n    BasePropertiesExtractorObjectExpressionHostNode =\n        'BasePropertiesExtractorObjectExpressionHostNode'\n}\n","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n","export enum ObfuscatingGuard {\n    BlackListObfuscatingGuard = 'BlackListObfuscatingGuard',\n    ConditionalCommentObfuscatingGuard = 'ConditionalCommentObfuscatingGuard',\n    ReservedStringObfuscatingGuard = 'ReservedStringObfuscatingGuard'\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @param {Comment} comment\n     * @returns {boolean}\n     */\n    public static isConditionalComment (comment: ESTree.Comment): boolean {\n        return ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value) ||\n            ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value);\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IMapStorage } from '../interfaces/storages/IMapStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <K, V> implements IMapStorage <K, V> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <K, V>}\n     */\n    @initializable()\n    protected storage!: Map <K, V>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <K, V>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V}\n     */\n    public get (key: K): V {\n        const value: V | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {K | null}\n     */\n    public getKeyOf (value: V): K | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map<K, V>}\n     */\n    public getStorage (): Map <K, V> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {K} key\n     * @returns {boolean}\n     */\n    public has (key: K): boolean {\n        return this.storage.has(key);\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <K, V>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    public set (key: K, value: V): void {\n        this.storage.set(key, value);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.randomGenerator = new Chance(this.getRawSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getInputSeed (): string {\n        return this.options.seed.toString();\n    }\n\n    /**\n     * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n     * for different bundles with same seed\n     *\n     * @returns {number}\n     */\n    public getRawSeed (): string {\n        const inputSeed: string = this.getInputSeed();\n        const inputSeedParts: string[] = `${inputSeed}`.split('|');\n\n        if (inputSeedParts.length > 1) {\n            return inputSeed;\n        }\n\n        const sourceCodeMD5Hash: string = md5(this.sourceCode.getSourceCode());\n\n        return `${inputSeed}|${sourceCodeMD5Hash}`;\n    }\n}\n","module.exports = require(\"chalk\");","module.exports = require(\"reflect-metadata\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\nimport { LoggingPrefix } from '../enums/logger/LoggingPrefix';\n\n@injectable()\nexport class Logger implements ILogger {\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorInfo: Chalk = chalk.cyan;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorSuccess: Chalk = chalk.green;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorWarn: Chalk = chalk.yellow;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingPrefix} loggingPrefix\n     * @param {string} loggingMessage\n     * @param {string | number} value\n     */\n    public static log (\n        loggingLevelColor: Chalk,\n        loggingPrefix: LoggingPrefix,\n        loggingMessage: string,\n        value?: string | number,\n    ): void {\n        const processedMessage: string = loggingLevelColor(`\\n${loggingPrefix} ${loggingMessage}`);\n\n        console.log(processedMessage, value || '');\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorInfo, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorSuccess, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorWarn, LoggingPrefix.Base, loggingMessage, value);\n    }\n}\n","export enum LoggingPrefix {\n    Base = '[javascript-obfuscator]',\n    CLI = '[javascript-obfuscator-cli]'\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeDataExtractor';\nimport { ICallsGraphAnalyzer } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphAnalyzer';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../../../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/calls-graph-analyzer/CalleeDataExtractor';\nimport { CallsGraphAnalyzer } from '../../../analyzers/calls-graph-analyzer/CallsGraphAnalyzer';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/calls-graph-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/calls-graph-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/calls-graph-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { PrevailingKindOfVariablesAnalyzer } from '../../../analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // calls graph analyzer\n    bind<ICallsGraphAnalyzer>(ServiceIdentifiers.ICallsGraphAnalyzer)\n        .to(CallsGraphAnalyzer)\n        .inSingletonScope();\n\n    // prevailing kind of variables analyzer\n    bind<IPrevailingKindOfVariablesAnalyzer>(ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)\n        .to(PrevailingKindOfVariablesAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // callee data extractor factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/calls-graph-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\nimport { ICallsGraphAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphAnalyzer';\nimport { ICallsGraphData } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/calls-graph-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n/**\n * This class generates a data with a graph of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class CallsGraphAnalyzer implements ICallsGraphAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = CallsGraphAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * CallsGraphAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {ICallsGraphData[]}\n     */\n    public analyze (astTree: ESTree.Program): ICallsGraphData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {ICallsGraphData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): ICallsGraphData[] {\n        const limitIndex: number = CallsGraphAnalyzer.getLimitIndex(blockScopeBody.length);\n        const callsGraphData: ICallsGraphData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeStatementUtils.getParentNodeWithStatements(node)) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(callsGraphData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return callsGraphData;\n    }\n\n    /**\n     * @param {ICallsGraphData[]} callsGraphData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        callsGraphData: ICallsGraphData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        CallsGraphAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            callsGraphData.push({\n                ...calleeData,\n                callsGraph: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/calls-graph-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {Property} propertyNode\n     * @param {string | number} nextItemInCallsChain\n     * @returns {boolean}\n     */\n    private static isValidTargetPropertyNode (propertyNode: ESTree.Property, nextItemInCallsChain: string | number): boolean {\n        if (!propertyNode.key) {\n            return false;\n        }\n\n        const isTargetPropertyNodeWithIdentifierKey: boolean =\n            NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n        const isTargetPropertyNodeWithLiteralKey: boolean =\n            NodeGuards.isLiteralNode(propertyNode.key) &&\n            Boolean(propertyNode.key.value) &&\n            propertyNode.key.value === nextItemInCallsChain;\n\n        return isTargetPropertyNodeWithIdentifierKey || isTargetPropertyNodeWithLiteralKey;\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            if (!ObjectExpressionCalleeDataExtractor.isValidTargetPropertyNode(propertyNode, nextItemInCallsChain)) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\n\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class PrevailingKindOfVariablesAnalyzer implements IPrevailingKindOfVariablesAnalyzer {\n    /**\n     * @type {ESTree.VariableDeclaration['kind']}\n     */\n    private static readonly defaultKindOfVariables: ESTree.VariableDeclaration['kind'] = 'var';\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {ESTree.VariableDeclaration['kind']}\n     */\n    private prevailingKindOfVariables: ESTree.VariableDeclaration['kind'] = PrevailingKindOfVariablesAnalyzer.defaultKindOfVariables;\n\n    constructor (\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils\n    ) {\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {Program} astTree\n     */\n    public analyze (astTree: ESTree.Program): void {\n        const variableKinds: ESTree.VariableDeclaration['kind'][] = [];\n\n        estraverse.traverse(astTree, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (!NodeGuards.isVariableDeclarationNode(node)) {\n                    return;\n                }\n\n                variableKinds.push(node.kind);\n            }\n        });\n\n        this.prevailingKindOfVariables = this.arrayUtils.findMostOccurringElement(variableKinds)\n            || PrevailingKindOfVariablesAnalyzer.defaultKindOfVariables;\n    }\n\n    /**\n     * @returns {VariableDeclaration[\"kind\"]}\n     */\n    public getPrevailingKind (): ESTree.VariableDeclaration['kind'] {\n        return this.prevailingKindOfVariables;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const operator: ESTree.BinaryOperator = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode<TInitialData<BinaryExpressionFunctionNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n        binaryExpressionFunctionCustomNode.initialize(operator);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            operator,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TInitialData } from '../../types/TInitialData';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { BlockStatementControlFlowFlatteningNode } from '../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedStatementNode (node: ESTree.Node): boolean {\n        const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(node)\n            || NodeGuards.isContinueStatementNode(node);\n        const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(node)\n            && (node.kind === 'const' || node.kind === 'let');\n        const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(node);\n\n        return NodeGuards.isFunctionDeclarationNode(node)\n            || isBreakOrContinueStatement\n            || isVariableDeclarationWithLetOrConstKind\n            || isClassDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (BlockStatementControlFlowTransformer.isProhibitedStatementNode(node)) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.createWithRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.shuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode<TInitialData<BlockStatementControlFlowFlatteningNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode<TInitialData<CallExpressionFunctionNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.CallExpressionFunctionNode);\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode<TInitialData<CallExpressionControlFlowStorageCallNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TInitialData } from '../../types/TInitialData';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { BlockStatementDeadCodeInjectionNode } from '../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TDeadNodeInjectionCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = NodeFactory.blockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const parentNodeWithStatements: TNodeWithStatements = NodeStatementUtils\n            .getParentNodeWithStatements(blockStatementNode);\n\n        return parentNodeWithStatements.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                const clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                const transformedBlockStatementNode: ESTree.BlockStatement =\n                    this.makeClonedBlockStatementNodeUnique(clonedBlockStatementNode);\n\n                this.collectedBlockStatements.push(transformedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * Make all identifiers in cloned block statement unique\n     *\n     * @param {BlockStatement} clonedBlockStatementNode\n     * @returns {BlockStatement}\n     */\n    private makeClonedBlockStatementNodeUnique (clonedBlockStatementNode: ESTree.BlockStatement): ESTree.BlockStatement {\n        // should wrap cloned block statement node into function node for correct scope encapsulation\n        const hostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], clonedBlockStatementNode);\n\n        NodeUtils.parentizeNode(hostNode, hostNode);\n        NodeUtils.parentizeNode(clonedBlockStatementNode, hostNode);\n\n        return this.transformersRunner.transform(\n            hostNode,\n            DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n            TransformationStage.Obfuscating\n        ).body;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.functionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode<TInitialData<BlockStatementDeadCodeInjectionNode>> =\n            this.deadCodeInjectionCustomNodeFactory(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorage } from '../../types/storages/TControlFlowStorage';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TInitialData } from '../../types/TInitialData';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { ControlFlowStorageNode } from '../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, TControlFlowStorage>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, TControlFlowStorage> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithStatements>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithStatements> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithStatements = this.getHostNode(functionNode.body);\n        const controlFlowStorage: TControlFlowStorage = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode<TInitialData<ControlFlowStorageNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.ControlFlowStorageNode);\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prepend(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        NodeUtils.parentizeAst(functionNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithStatements} hostNode\n     * @returns {TControlFlowStorage}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithStatements): TControlFlowStorage {\n        const controlFlowStorage: TControlFlowStorage = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                if (NodeGuards.isSwitchCaseNode(hostNode)) {\n                    hostNode.consequent.shift();\n                } else {\n                    hostNode.body.shift();\n                }\n            }\n\n            const hostControlFlowStorage: TControlFlowStorage = <TControlFlowStorage>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithStatements}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithStatements {\n        const blockScopesOfNode: TNodeWithStatements[] = NodeStatementUtils.getParentNodesWithStatements(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: TControlFlowStorage): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const operator: ESTree.LogicalOperator = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode<TInitialData<LogicalExpressionFunctionNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n        logicalExpressionFunctionCustomNode.initialize(operator);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            operator,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode<TInitialData<StringLiteralNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.StringLiteralNode);\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode<TInitialData<StringLiteralControlFlowStorageCallNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { PropertiesExtractor } from '../../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\n\nimport { AssignmentExpressionPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor';\nimport { BasePropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/BasePropertiesExtractor';\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionTransformer';\nimport { SplitStringTransformer } from '../../../node-transformers/converting-transformers/SplitStringTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\nimport { VariableDeclaratorPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(SplitStringTransformer)\n        .whenTargetNamed(NodeTransformer.SplitStringTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n\n    // properties extractors\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(AssignmentExpressionPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.AssignmentExpressionPropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(BasePropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.BasePropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(VariableDeclaratorPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.VariableDeclaratorPropertiesExtractor);\n\n    // properties extractor factory\n    bind<IPropertiesExtractor>(ServiceIdentifiers.Factory__IPropertiesExtractor)\n        .toFactory<IPropertiesExtractor>(InversifyContainerFacade\n            .getCacheFactory<PropertiesExtractor, IPropertiesExtractor>(\n                ServiceIdentifiers.IPropertiesExtractor\n            ));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class AssignmentExpressionPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    private static isProhibitedHostParent (node: ESTree.Node): node is ESTree.Pattern {\n        if (NodeGuards.isMemberExpressionNode(node)) {\n            return true;\n        }\n\n        if (AssignmentExpressionPropertiesExtractor.isProhibitedStatementNode(node)) {\n            return true;\n        }\n\n        // statements without block statement\n        return NodeGuards.isExpressionStatementNode(node)\n            && !!node.parentNode\n            && AssignmentExpressionPropertiesExtractor.isProhibitedStatementNode(node.parentNode);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedStatementNode (node: ESTree.Node): boolean {\n        return NodeGuards.isIfStatementNode(node)\n            || NodeGuards.isForStatementTypeNode(node)\n            || NodeGuards.isWhileStatementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {AssignmentExpression} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.AssignmentExpression\n    ): ESTree.Node {\n        const hostParentNode: ESTree.Node | undefined = hostNode.parentNode;\n        const leftNode: ESTree.MemberExpression | ESTree.Pattern = hostNode.left;\n\n        // left node shouldn't be as Pattern node\n        if (AbstractPropertiesExtractor.isProhibitedPattern(leftNode)) {\n            return objectExpressionNode;\n        }\n\n        // left node shouldn't be as prohibited node\n        if (hostParentNode && AssignmentExpressionPropertiesExtractor.isProhibitedHostParent(hostParentNode)) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            leftNode\n        );\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\nimport { TObjectExpressionKeysTransformerCustomNodeFactory } from '../../../types/container/custom-nodes/TObjectExpressionKeysTransformerCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ObjectExpressionKeysTransformerCustomNode } from '../../../enums/custom-nodes/ObjectExpressionKeysTransformerCustomNode';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { BasePropertiesExtractorObjectExpressionHostNode } from '../../../custom-nodes/object-expression-keys-transformer-nodes/BasePropertiesExtractorObjectExpressionHostNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BasePropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @type {TObjectExpressionKeysTransformerCustomNodeFactory}\n     */\n    private readonly objectExpressionKeysTransformerCustomNodeFactory: TObjectExpressionKeysTransformerCustomNodeFactory;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {TObjectExpressionKeysTransformerCustomNodeFactory} objectExpressionKeysTransformerCustomNodeFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.Factory__IObjectExpressionKeysTransformerCustomNode)\n            objectExpressionKeysTransformerCustomNodeFactory: TObjectExpressionKeysTransformerCustomNodeFactory,\n    ) {\n        super(randomGenerator, options);\n\n        this.objectExpressionKeysTransformerCustomNodeFactory = objectExpressionKeysTransformerCustomNodeFactory;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        parentNode: ESTree.Node\n    ): ESTree.Node {\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            parentNode\n        );\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        parentNode: ESTree.Node\n    ): ESTree.Node {\n        const newObjectExpressionHostNode: ESTree.VariableDeclaration = this.getObjectExpressionHostNode();\n        const newObjectExpressionIdentifier: ESTree.Identifier = this.getObjectExpressionIdentifierNode(newObjectExpressionHostNode);\n\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, newObjectExpressionIdentifier);\n        const statementsToInsert: TStatement[] = [\n            newObjectExpressionHostNode,\n            ...expressionStatements\n        ];\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const hostNodeWithStatements: TNodeWithStatements = this.getHostNodeWithStatements(\n            objectExpressionNode,\n            hostStatement\n        );\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertBefore(hostNodeWithStatements, statementsToInsert, hostStatement);\n\n        return newObjectExpressionIdentifier;\n    }\n\n    /**\n     * @returns {VariableDeclaration}\n     */\n    private getObjectExpressionHostNode (): ESTree.VariableDeclaration {\n        const objectExpressionHostCustomNode: ICustomNode<TInitialData<BasePropertiesExtractorObjectExpressionHostNode>> =\n            this.objectExpressionKeysTransformerCustomNodeFactory(\n                ObjectExpressionKeysTransformerCustomNode.BasePropertiesExtractorObjectExpressionHostNode\n            );\n\n        objectExpressionHostCustomNode.initialize();\n\n        const statementNode: TStatement = objectExpressionHostCustomNode.getNode()[0];\n\n        if (\n            !statementNode\n            || !NodeGuards.isVariableDeclarationNode(statementNode)\n        ) {\n            throw new Error(`\\`objectExpressionHostCustomNode.getNode()[0]\\` should returns array with \\`VariableDeclaration\\` node`);\n        }\n\n        return statementNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} objectExpressionHostNode\n     * @returns {Identifier}\n     */\n    private getObjectExpressionIdentifierNode (objectExpressionHostNode: ESTree.VariableDeclaration): ESTree.Identifier {\n        const newObjectExpressionIdentifierNode: ESTree.Pattern = objectExpressionHostNode.declarations[0].id;\n\n        if (!NodeGuards.isIdentifierNode(newObjectExpressionIdentifierNode)) {\n            throw new Error(`\\`objectExpressionHostNode\\` should contain \\`VariableDeclarator\\` node with \\`Identifier\\` id property`);\n        }\n\n        return newObjectExpressionIdentifierNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = NodeFactory.literalNode(memberExpressionNode.property.name);\n        }\n\n        return memberExpressionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * or\n *     'foo' () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(methodDefinitionNode.key)) {\n            return this.replaceIdentifierKey(methodDefinitionNode, methodDefinitionNode.key);\n        }\n\n        if (NodeGuards.isLiteralNode(methodDefinitionNode.key)) {\n            return this.replaceLiteralKey(methodDefinitionNode, methodDefinitionNode.key);\n        }\n\n        return methodDefinitionNode;\n    }\n\n    /**\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {Identifier} keyNode\n     * @returns {MethodDefinition}\n     */\n    private replaceIdentifierKey (\n        methodDefinitionNode: ESTree.MethodDefinition,\n        keyNode: ESTree.Identifier\n    ): ESTree.MethodDefinition {\n        if (\n            !MethodDefinitionTransformer.ignoredNames.includes(keyNode.name)\n            && !methodDefinitionNode.computed\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = NodeFactory.literalNode(keyNode.name);\n        }\n\n        return methodDefinitionNode;\n    }\n\n    /**\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {Literal} keyNode\n     * @returns {MethodDefinition}\n     */\n    private replaceLiteralKey (\n        methodDefinitionNode: ESTree.MethodDefinition,\n        keyNode: ESTree.Literal\n    ): ESTree.MethodDefinition {\n        if (\n            typeof keyNode.value === 'string'\n            && !MethodDefinitionTransformer.ignoredNames.includes(keyNode.value)\n            && !methodDefinitionNode.computed\n        ) {\n            methodDefinitionNode.computed = true;\n        }\n\n        return methodDefinitionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TPropertiesExtractorFactory } from '../../types/container/node-transformers/TPropertiesExtractorFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { PropertiesExtractor } from '../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<string, PropertiesExtractor>}\n     */\n    private static readonly propertiesExtractorsMap: Map <string, PropertiesExtractor> = new Map([\n        [NodeType.AssignmentExpression, PropertiesExtractor.AssignmentExpressionPropertiesExtractor],\n        [NodeType.VariableDeclarator, PropertiesExtractor.VariableDeclaratorPropertiesExtractor]\n    ]);\n\n    /**\n     * @type {TPropertiesExtractorFactory}\n     */\n    private readonly propertiesExtractorFactory: TPropertiesExtractorFactory;\n\n    /**\n     * @param {TPropertiesExtractorFactory} propertiesExtractorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IPropertiesExtractor)\n            propertiesExtractorFactory: TPropertiesExtractorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.propertiesExtractorFactory = propertiesExtractorFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        if (!this.options.transformObjectKeys) {\n            return null;\n        }\n\n        if (transformationStage !== TransformationStage.Converting) {\n            return null;\n        }\n\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            },\n            leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNodeWithBaseExtractor(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractorName: PropertiesExtractor | undefined = ObjectExpressionKeysTransformer\n            .propertiesExtractorsMap\n            .get(parentNode.type);\n\n        if (!propertiesExtractorName) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(propertiesExtractorName);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n\n    /**\n     * replaces:\n     *     return {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *     return object;\n     *\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNodeWithBaseExtractor (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(PropertiesExtractor.BasePropertiesExtractor);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (!property.key) {\n                    return;\n                }\n\n                if (property.computed) {\n                    this.transformComputedProperty(property);\n                } else {\n                    this.transformBaseProperty(property);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformComputedProperty (property: ESTree.Property): void {\n        if (!NodeGuards.isLiteralNode(property.key) || !(typeof property.key.value === 'string')) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.value));\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformBaseProperty (property: ESTree.Property): void {\n        if (property.shorthand) {\n            property.shorthand = false;\n        }\n\n        if (!NodeGuards.isIdentifierNode(property.key)) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.name));\n    }\n\n    /**\n     * @param {string} inputValue\n     * @returns {string}\n     */\n    private getPropertyKeyValue (inputValue: string): string {\n        return this.options.unicodeEscapeSequence\n            ? this.escapeSequenceEncoder.encode(inputValue, true)\n            : inputValue;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Splits strings into parts\n */\n@injectable()\nexport class SplitStringTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {NodeTransformer[]}\n     */\n    public runAfter: NodeTransformer[] = [\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.TemplateLiteralTransformer\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {string} string\n     * @param {number} chunkSize\n     * @returns {string[]}\n     */\n    private static chunkString (string: string, chunkSize: number): string[] {\n        const chunksCount: number = Math.ceil(string.length / chunkSize);\n        const chunks: string[] = [];\n\n        let nextChunkStartIndex: number = 0;\n\n        for (\n            let chunkIndex: number = 0;\n            chunkIndex < chunksCount;\n            ++chunkIndex, nextChunkStartIndex += chunkSize\n        ) {\n            chunks[chunkIndex] = string.substr(nextChunkStartIndex, chunkSize);\n        }\n\n        return chunks;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (!this.options.splitStrings) {\n                            return;\n                        }\n\n                        if (parentNode && NodeGuards.isLiteralNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (typeof literalNode.value !== 'string') {\n            return literalNode;\n        }\n\n        if (NodeGuards.isPropertyNode(parentNode) && !parentNode.computed && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (this.options.splitStringsChunkLength >= literalNode.value.length) {\n            return literalNode;\n        }\n\n        const stringChunks: string[] = SplitStringTransformer.chunkString(\n            literalNode.value,\n            this.options.splitStringsChunkLength\n        );\n\n        return this.transformStringChunksToBinaryExpressionNode(stringChunks);\n    }\n\n    /**\n     * @param {string[]} chunks\n     * @returns {BinaryExpression}\n     */\n    private transformStringChunksToBinaryExpressionNode (chunks: string[]): ESTree.BinaryExpression | ESTree.Literal {\n        const lastChunk: string | undefined = chunks.pop();\n\n        if (lastChunk === undefined) {\n            throw new Error('Last chunk value should not be empty');\n        }\n\n        const lastChunkLiteralNode: ESTree.Literal = NodeFactory.literalNode(lastChunk);\n\n        if (chunks.length === 0) {\n            return lastChunkLiteralNode;\n        }\n\n        return NodeFactory.binaryExpressionNode(\n            '+',\n            this.transformStringChunksToBinaryExpressionNode(chunks),\n            lastChunkLiteralNode\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node | null} parentNode\n     * @returns {boolean}\n     */\n    private static isValidTemplateLiteralNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.TemplateLiteral {\n        return NodeGuards.isTemplateLiteralNode(node) && !NodeGuards.isTaggedTemplateExpressionNode(parentNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && TemplateLiteralTransformer.isValidTemplateLiteralNode(node, parentNode)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(NodeFactory.literalNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(NodeFactory.literalNode(''));\n        }\n\n        let transformedNode: ESTree.Node;\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = NodeFactory.binaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = NodeFactory.binaryExpressionNode('+', root, node);\n            });\n\n            transformedNode = root;\n        } else {\n            transformedNode = nodes[0];\n        }\n\n        NodeUtils.parentizeAst(transformedNode);\n\n        return transformedNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class VariableDeclaratorPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {VariableDeclarator} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        if (\n            !NodeGuards.isIdentifierNode(hostNode.id)\n            || this.isProhibitedObjectExpressionNode(objectExpressionNode, hostNode.id)\n        ) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(objectExpressionNode, hostNode.id);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @returns {VariableDeclarator}\n     */\n    private getHostVariableDeclaratorNode (objectExpressionNode: ESTree.ObjectExpression): ESTree.VariableDeclarator | never {\n        const { parentNode } = objectExpressionNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclaratorNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclarator` node for `ObjectExpression` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {VariableDeclarator} variableDeclaratorNode\n     * @returns {VariableDeclaration}\n     */\n    private getHostVariableDeclarationNode (variableDeclaratorNode: ESTree.VariableDeclarator): ESTree.VariableDeclaration | never {\n        const { parentNode } = variableDeclaratorNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclarationNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclaration` node for `VariableDeclarator` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Identifier} memberExpressionHostNode\n     * @returns {boolean}\n     */\n    private isProhibitedObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Identifier\n    ): boolean {\n        const hostVariableDeclarator: ESTree.VariableDeclarator = this.getHostVariableDeclaratorNode(objectExpressionNode);\n        const hostVariableDeclaration: ESTree.VariableDeclaration = this.getHostVariableDeclarationNode(hostVariableDeclarator);\n        const { declarations } = hostVariableDeclaration;\n        const indexOfDeclarator: number = declarations.indexOf(hostVariableDeclarator);\n        const isLastDeclarator: boolean = indexOfDeclarator === (declarations.length - 1);\n\n        // avoid unnecessary checks\n        if (isLastDeclarator) {\n            return false;\n        }\n\n        const declaratorsAfterCurrentDeclarator: ESTree.VariableDeclarator[] = declarations.slice(indexOfDeclarator);\n\n        let isProhibitedObjectExpressionNode: boolean = false;\n\n        // should mark node as prohibited if that node using inside other variable declarators\n        declaratorsAfterCurrentDeclarator.forEach((variableDeclarator: ESTree.VariableDeclarator) => {\n            estraverse.traverse(variableDeclarator, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | ESTree.Node => {\n                    if (\n                        NodeGuards.isMemberExpressionNode(node)\n                        && NodeGuards.isIdentifierNode(node.object)\n                        && node.object.name === memberExpressionHostNode.name\n                    ) {\n                        isProhibitedObjectExpressionNode = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n\n                    return node;\n                }\n            });\n        });\n\n        return isProhibitedObjectExpressionNode;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { ObjectExpressionKeysTransformerCustomNode } from '../../../enums/custom-nodes/ObjectExpressionKeysTransformerCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BasePropertiesExtractorObjectExpressionHostNode } from '../../../custom-nodes/object-expression-keys-transformer-nodes/BasePropertiesExtractorObjectExpressionHostNode';\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { CustomNodeFormatter } from '../../../custom-nodes/CustomNodeFormatter';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // object expression keys transformer nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BasePropertiesExtractorObjectExpressionHostNode)\n        .whenTargetNamed(ObjectExpressionKeysTransformerCustomNode.BasePropertiesExtractorObjectExpressionHostNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.ICustomNodeFormatter,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions,\n                ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.ICustomNodeFormatter,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // object expression keys transformer customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IObjectExpressionKeysTransformerCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ObjectExpressionKeysTransformerCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.ICustomNodeFormatter,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions,\n                ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n\n    // custom node formatter\n    bind<ICustomNodeFormatter>(ServiceIdentifiers.ICustomNodeFormatter)\n        .to(CustomNodeFormatter)\n        .inSingletonScope();\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { ConsoleOutputDisableExpressionNode } from '../ConsoleOutputDisableExpressionNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode<TInitialData<ConsoleOutputDisableExpressionNode>> =\n            this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { DebugProtectionFunctionNode } from '../DebugProtectionFunctionNode';\nimport { DebugProtectionFunctionCallNode } from '../DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../DebugProtectionFunctionIntervalNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.append(nodeWithStatements, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = NodeGuards.isSwitchCaseNode(nodeWithStatements)\n                ? nodeWithStatements.consequent.length\n                : nodeWithStatements.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode<TInitialData<DebugProtectionFunctionNode>> =\n            this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode<TInitialData<DebugProtectionFunctionCallNode>> =\n            this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode<TInitialData<DebugProtectionFunctionIntervalNode>> =\n            this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { DomainLockNode } from '../DomainLockNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode<TInitialData<DomainLockNode>> =\n            this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../SelfDefendingUnicodeNode';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode<TInitialData<SelfDefendingUnicodeNode>> =\n            this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { StringArrayNode } from '../StringArrayNode';\nimport { StringArrayCallsWrapper } from '../StringArrayCallsWrapper';\nimport { StringArrayRotateFunctionNode } from '../StringArrayRotateFunctionNode';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prepend(nodeWithStatements, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode<TInitialData<StringArrayNode>> =\n            this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode<TInitialData<StringArrayCallsWrapper>> =\n            this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode<TInitialData<StringArrayRotateFunctionNode>> =\n            this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const [stringArrayName, stringArrayCallsWrapperName]: string[] = stringArrayStorageId.split('|');\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = this.randomGenerator.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class BasePropertiesExtractorObjectExpressionHostNode extends AbstractCustomNode {\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    public initialize (): void {}\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.variableDeclarationNode(\n            [\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(\n                        this.identifierNamesGenerator.generate()\n                    ),\n                    NodeFactory.objectExpressionNode([])\n                )\n            ],\n            'const'\n        );\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        let that;\n        \n        try {\n            const getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        const getGlobal = function () {\n            let globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        const that = getGlobal();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.binaryExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.variableDeclarationNode(\n                [\n                    NodeFactory.variableDeclaratorNode(\n                        NodeFactory.identifierNode(controllerIdentifierName),\n                        NodeFactory.callExpressionNode(\n                            NodeFactory.memberExpressionNode(\n                                NodeFactory.literalNode(\n                                    this.originalKeysIndexesInShuffledArray.join('|')\n                                ),\n                                NodeFactory.identifierNode('split')\n                            ),\n                            [\n                                NodeFactory.literalNode('|')\n                            ]\n                        )\n                    )\n                ],\n                'const'\n            ),\n            NodeFactory.variableDeclarationNode(\n                [\n                    NodeFactory.variableDeclaratorNode(\n                        NodeFactory.identifierNode(indexIdentifierName),\n                        NodeFactory.literalNode(0)\n                    )\n                ],\n                'let'\n            ),\n            NodeFactory.whileStatementNode(\n                NodeFactory.literalNode(true),\n                NodeFactory.blockStatementNode([\n                    NodeFactory.switchStatementNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.identifierNode(controllerIdentifierName),\n                            NodeFactory.updateExpressionNode(\n                                '++',\n                                NodeFactory.identifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(NodeFactory.continueStatement());\n                            }\n\n                            return NodeFactory.switchCaseNode(\n                                NodeFactory.literalNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    NodeFactory.breakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.ifStatementNode(\n                NodeFactory.binaryExpressionNode(\n                    operator,\n                    NodeFactory.literalNode(leftString),\n                    NodeFactory.literalNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\n// tslint:disable\nimport { Expression } from 'estree';\n// tslint:enable\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = NodeFactory.identifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(NodeFactory.identifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.callExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {TControlFlowStorage}\n     */\n    @initializable()\n    private controlFlowStorage!: TControlFlowStorage;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: TControlFlowStorage): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return NodeFactory.propertyNode(\n                    NodeFactory.identifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = NodeFactory.variableDeclarationNode(\n            [\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()),\n                    NodeFactory.objectExpressionNode(propertyNodes)\n                )\n            ],\n            'const'\n        );\n\n        structure = NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return this.customNodeFormatter.formatTemplate(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        const {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            const func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    const c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.table = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.table = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\nimport format from 'string-template';\n\nimport { TObject } from '../types/TObject';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNodeFormatter } from '../interfaces/custom-nodes/ICustomNodeFormatter';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\n\nimport { NodeGuards } from '../node/NodeGuards';\n\n@injectable()\nexport class CustomNodeFormatter implements ICustomNodeFormatter {\n    /**\n     * @type {ESTree.VariableDeclaration['kind']}\n     */\n    private readonly prevailingKindOfVariables: ESTree.VariableDeclaration['kind'];\n\n    constructor (\n        @inject(ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)\n            prevailingKindOfVariablesAnalyzer: IPrevailingKindOfVariablesAnalyzer\n    ) {\n        this.prevailingKindOfVariables = prevailingKindOfVariablesAnalyzer.getPrevailingKind();\n    }\n\n    /**\n     * @param {string} template\n     * @param {TMapping} mapping\n     * @returns {string}\n     */\n    public formatTemplate <TMapping extends TObject> (\n        template: string,\n        mapping: TMapping\n    ): string {\n        return format(template, mapping);\n    }\n\n    /**\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    public formatStructure (statements: TStatement[]): TStatement[] {\n        for (const statement of statements) {\n            estraverse.replace(statement, {\n                enter: (node: ESTree.Node): ESTree.Node | void => {\n                    if (!NodeGuards.isVariableDeclarationNode(node)) {\n                        return;\n                    }\n\n                    if (this.prevailingKindOfVariables === 'var') {\n                        node.kind = 'var';\n                    }\n\n                    return node;\n                }\n            });\n        }\n\n        return statements;\n    }\n}\n","module.exports = require(\"string-template\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return this.customNodeFormatter.formatTemplate(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(\n                this,\n                function () {\n                    const regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                    const regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:[a-zA-Z_$][0-9a-zA-Z_$]*\\\\)', 'i');\n           \n                    const result = {debugProtectionFunctionName}('init');\n                    \n                    if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                        result('0');\n                    } else {\n                        {debugProtectionFunctionName}();\n                    }\n                }\n            )();\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return this.customNodeFormatter.formatTemplate(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return this.customNodeFormatter.formatTemplate(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            const func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {ICryptUtils} cryptUtils\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return this.customNodeFormatter.formatTemplate(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        const {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            const func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (let i = 0; i < 1000; i--) {\n                            const isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            const regExp = new RegExp(\"[{diff}]\", \"g\");\n            const domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            let document;\n            let domain;\n            let location;\n            let hostname;\n\n            for (let d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (let d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n\n            if (!(\"~\" > domain)) {\n                for (let d2 in that[document]) {\n                    if (d2.length == 8 && d2.charCodeAt(7) == 110 && d2.charCodeAt(0) == 108) {\n                        location = d2;\n                        \n                        break;\n                    }\n                }\n\n                for (let d3 in that[document][location]) {\n                    if (d3.length == 8 && d3.charCodeAt(7) == 101 && d3.charCodeAt(0) == 104) {\n                        hostname = d3;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            if (!document || !that[document]) {\n                return;\n            }\n            \n            const documentDomain = that[document][domain];\n            const documentLocationHostName = !!that[document][location] && that[document][location][hostname];\n            const currentDomain = documentDomain || documentLocationHostName;\n          \n            if (!currentDomain) {\n                return;\n            }\n          \n            let ok = false;\n                        \n            for (let i = 0; i < domains.length; i++) {\n                const domain = domains[i];\n                const position = currentDomain.length - domain.length;\n                const lastIndex = currentDomain.indexOf(domain, position);\n                const endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.logicalExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                this.customNodeFormatter.formatTemplate(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    identifiersDictionary: this.options.identifiersDictionary,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return this.customNodeFormatter.formatTemplate(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        const {singleNodeCallControllerFunctionName} = (function(){\n            let firstCall = true;\n            \n            return function (context, fn){\n                const rfn = firstCall ? function(){\n                    if(fn){\n                        const res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            this.customNodeFormatter.formatTemplate(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                identifiersDictionary: this.options.identifiersDictionary,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        const {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            const func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            const test1 = function () {\n                const regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            const test2 = function () {\n                const regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            const recursiveFunc1 = function (string) {\n                const i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            const recursiveFunc2 = function (string) {\n                const i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            this.customNodeFormatter.formatTemplate(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                identifiersDictionary: this.options.identifiersDictionary,\n                seed: this.randomGenerator.getRawSeed()\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = this.customNodeFormatter.formatTemplate(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = this.customNodeFormatter.formatTemplate(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = this.customNodeFormatter.formatTemplate(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = this.customNodeFormatter.formatTemplate(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    const str = String(input).replace(/=+$/, '');\n                    let output = '';\n                    for (\n                        let bc = 0, bs, buffer, idx = 0;\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                    return output;\n                }\n            );\n        })();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        const rc4 = function (str, key) {\n            let s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (let k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t     \n            let i;\n                    \t        \n\t        for (i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (let y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        const StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            const regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            const expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (let i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                const string = atob(str);\n                let newStringChars = [];\n                \n                for (let i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        const cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        const {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            let value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        const cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\nimport { TStringArrayStorage } from '../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {TStringArrayStorage}\n     */\n    @initializable()\n    private stringArrayStorage!: TStringArrayStorage;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: TStringArrayStorage,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return this.customNodeFormatter.formatTemplate(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        const {stringArrayName} = [{stringArray}];\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { NumberUtils } from '../../utils/NumberUtils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = this.customNodeFormatter.formatTemplate(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            this.customNodeFormatter.formatTemplate(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: NumberUtils.toHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                identifiersDictionary: this.options.identifiersDictionary,\n                seed: this.randomGenerator.getRawSeed()\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        const selfDefendingFunc = function () {\n            const object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    let updatedCookie = name + \"=\" + value;\n                    let i = 0;\n                                                            \n                    for (let i = 0, len = options.length; i < len; i++) {\n                        const propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        const propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    const matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    const func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            const test1 = function () {\n                const regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            let cookie = '';\n            const result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            const {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.memberExpressionNode(\n                NodeFactory.identifierNode(this.controlFlowStorageName),\n                NodeFactory.identifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.literalNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { DictionaryIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/DictionaryIdentifierNamesGenerator';\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(DictionaryIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    function identifierNameGeneratorFactory (): (context: interfaces.Context) => (options: IOptions) => IIdentifierNamesGenerator {\n        let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n        return (context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => (options: IOptions) => {\n            if (cachedIdentifierNamesGenerator) {\n                return cachedIdentifierNamesGenerator;\n            }\n\n            let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n            switch (options.identifierNamesGenerator) {\n                case IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator:\n                    identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                        ServiceIdentifiers.IIdentifierNamesGenerator,\n                        IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator\n                    );\n\n                    break;\n\n                case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                    identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                        ServiceIdentifiers.IIdentifierNamesGenerator,\n                        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                    );\n\n                    break;\n\n                case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                default:\n                    identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                        ServiceIdentifiers.IIdentifierNamesGenerator,\n                        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                    );\n            }\n\n            cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n            return identifierNamesGenerator;\n        };\n    }\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>(identifierNameGeneratorFactory());\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class DictionaryIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {Set<string>}\n     */\n    private identifierNamesSet: Set<string>;\n    \n    /**\n     * @type {IterableIterator<string>}\n     */\n    private identifiersIterator: IterableIterator<string>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IArrayUtils} arrayUtils\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n    ) {\n        super(randomGenerator, options);\n\n        this.arrayUtils = arrayUtils;\n        this.identifierNamesSet = new Set(this.getInitialIdentifierNames(this.options.identifiersDictionary));\n        this.identifiersIterator = this.identifierNamesSet.values();\n    }\n\n    /**\n     * @param {string} identifierName\n     * @returns {string | null}\n     */\n    private static incrementIdentifierName (identifierName: string): string | null {\n        let newIdentifierName: string = '';\n        let isSuccess: boolean = false;\n\n        for (const character of identifierName) {\n            if (!isSuccess && character === character.toUpperCase()) {\n                newIdentifierName += character.toLowerCase();\n            } else if (!isSuccess && character === character.toLowerCase()) {\n                newIdentifierName += character.toUpperCase();\n                isSuccess = true;\n            } else {\n                newIdentifierName += character;\n            }\n        }\n\n        if (isSuccess) {\n            return newIdentifierName;\n        }\n\n        return null;\n    }\n\n    public generate (): string {\n        if (!this.identifierNamesSet.size) {\n            throw new Error('Too many identifiers in the code, add more words to identifiers dictionary');\n        }\n\n        const iteratorResult: IteratorResult<string> = this.identifiersIterator.next();\n\n        if (!iteratorResult.done) {\n            return iteratorResult.value;\n        }\n\n        this.identifierNamesSet = new Set(this.getIncrementedIdentifierNames([...this.identifierNamesSet]));\n        this.identifiersIterator = this.identifierNamesSet.values();\n\n        return this.generate();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate();\n\n        return `${prefix}${identifierName}`.replace('__', '_');\n    }\n\n    /**\n     * @param {string[]} identifierNames\n     * @returns {string[]}\n     */\n    private getInitialIdentifierNames (identifierNames: string[]): string[] {\n        const formattedIdentifierNames: string[] = identifierNames\n            .filter(Boolean)\n            .map((identifierName: string) => identifierName.toLowerCase());\n\n        return this.arrayUtils.shuffle(formattedIdentifierNames);\n    }\n\n    /**\n     * @param {string[]} identifierNames\n     * @returns {string[]}\n     */\n    private getIncrementedIdentifierNames (identifierNames: string[]): string[] {\n        const formattedIdentifierNames: string[] = [];\n\n        for (const identifierName of identifierNames) {\n            const newIdentifierName: string | null = DictionaryIdentifierNamesGenerator\n                .incrementIdentifierName(identifierName);\n\n            if (newIdentifierName) {\n                formattedIdentifierNames.push(newIdentifierName);\n            }\n        }\n\n        return this.arrayUtils.shuffle(formattedIdentifierNames);\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { NumberUtils } from '../../utils/NumberUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = NumberUtils.toHex(randomInteger);\n        const prefixLength: number = Utils.hexadecimalPrefix.length + 1;\n        const baseNameLength: number = nameLength\n            ? nameLength - prefixLength\n            : HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength;\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, baseNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate(nameLength);\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const identifierName: string = this.generate(nameLength);\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * We can only ignore limited nameLength, it has no sense here\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const identifierName: string = this.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate(nameLength);\n\n        return `${prefix}${identifierName}`;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (mangledName: string): boolean {\n        return super.isValidIdentifierName(mangledName)\n            && !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!this.isValidIdentifierName(newMangledName)) {\n            newMangledName = this.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { ClassDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ClassDeclarationTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { ImportDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ImportDeclarationTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformer.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ClassDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ClassDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ImportDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ImportDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.VariableDeclarationTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithLexicalScope } from '../../../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<TNodeWithLexicalScope, Map<string, string>>}\n     */\n    private readonly blockScopesMap: Map<TNodeWithLexicalScope, Map<string, string>> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Identifier}\n     */\n    public replace (nodeValue: string, lexicalScopeNode: TNodeWithLexicalScope): ESTree.Identifier {\n        if (this.blockScopesMap.has(lexicalScopeNode)) {\n            const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n            if (namesMap.has(nodeValue)) {\n                nodeValue = <string>namesMap.get(nodeValue);\n            }\n        }\n\n        return NodeFactory.identifierNode(nodeValue);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeGlobalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeLocalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generate();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * Preserve `name` to protect it from further using.\n     *\n     * @param {string} name\n     */\n    public preserveName (name: string): void {\n        this.identifierNamesGenerator.preserveName(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        if (!this.options.reservedNames.length) {\n            return false;\n        }\n\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            NodeFactory.arrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {boolean} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: boolean): ESTree.Node {\n        return nodeValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isCatchClauseNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(catchClauseNode);\n\n        if (!lexicalScopeNode) {\n            return catchClauseNode;\n        }\n\n        this.storeCatchClauseParam(catchClauseNode, lexicalScopeNode);\n        this.replaceCatchClauseParam(catchClauseNode, lexicalScopeNode);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        if (catchClauseNode.param && NodeGuards.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierObfuscatingReplacer.storeLocalName(catchClauseNode.param.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     class Foo { //... };\n *     new Foo();\n *\n * on:\n *     class _0x12d45f { //... };\n *     new _0x12d45f();\n */\n@injectable()\nexport class ClassDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isClassDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (\n        classDeclarationNode: ESTree.ClassDeclaration & { id: ESTree.Identifier },\n        parentNode: ESTree.Node\n    ): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(classDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return classDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return classDeclarationNode;\n        }\n\n        this.storeClassName(classDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(classDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return classDeclarationNode;\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeClassName (\n        classDeclarationNode: ESTree.ClassDeclaration & { id: ESTree.Identifier },\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(classDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(classDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        classDeclarationNode: ESTree.ClassDeclaration & { id: ESTree.Identifier },\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(classDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isFunctionDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (\n        functionDeclarationNode: ESTree.FunctionDeclaration & { id: ESTree.Identifier },\n        parentNode: ESTree.Node\n    ): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(parentNode);\n\n        if (!lexicalScopeNode) {\n            return functionDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(functionDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeFunctionName (\n        functionDeclarationNode: ESTree.FunctionDeclaration & { id: ESTree.Identifier },\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        functionDeclarationNode: ESTree.FunctionDeclaration & { id: ESTree.Identifier },\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(functionDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && (parentNode !== lexicalScopeNode)\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeType } from '../../enums/node/NodeType';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private static isProhibitedIdentifierOfPropertyNode (\n        node: ESTree.Node,\n        parentNode: ESTree.Node | null\n    ): node is ESTree.Identifier {\n        return NodeGuards.isIdentifierNode(node)\n            && !!parentNode\n            && NodeGuards.isPropertyNode(parentNode)\n            && parentNode.key === node;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedIdentifierOfShorthandPropertyNode (\n        node: ESTree.Node,\n    ): node is ESTree.Property & {key: ESTree.Identifier} {\n        return NodeGuards.isPropertyNode(node)\n            && node.shorthand\n            && NodeGuards.isIdentifierNode(node.key);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isFunctionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(functionNode);\n\n        if (!lexicalScopeNode) {\n            return functionNode;\n        }\n\n        this.storeFunctionParams(functionNode, lexicalScopeNode);\n        this.replaceFunctionParams(functionNode, lexicalScopeNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {Identifier} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isGlobalFunctionDeclarationIdentifier (node: ESTree.Identifier, parentNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(parentNode) || parentNode.id !== node) {\n            return false;\n        }\n\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScopes(parentNode)[1];\n\n        if (!lexicalScopeNode) {\n            return false;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        return !this.options.renameGlobals && isGlobalDeclaration;\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const visitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                // should check with identifier as first argument,\n                // because prohibited identifier can be easily ignored\n                if (FunctionTransformer.isProhibitedIdentifierOfPropertyNode(node, parentNode)) {\n                    return;\n                }\n\n                if (NodeGuards.isAssignmentPatternNode(node) && NodeGuards.isIdentifierNode(node.left)) {\n                    this.identifierObfuscatingReplacer.storeLocalName(node.left.name, lexicalScopeNode);\n\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (NodeGuards.isIdentifierNode(node)) {\n                    this.identifierObfuscatingReplacer.storeLocalName(node.name, lexicalScopeNode);\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => {\n            estraverse.traverse(paramsNode, visitor);\n        });\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Set<string>} ignoredIdentifierNamesSet\n     */\n    private replaceFunctionParams (\n        functionNode: ESTree.Function,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        ignoredIdentifierNamesSet: Set <string> = new Set()\n    ): void {\n        const visitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void | estraverse.VisitorOption => {\n                /**\n                 * should process nested functions in different traverse loop to avoid wrong code generation\n                 */\n                if (NodeGuards.isFunctionNode(node) && node !== functionNode) {\n                    this.replaceFunctionParams(node, lexicalScopeNode, new Set(ignoredIdentifierNamesSet));\n\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                /**\n                 * should ignore all shorthand `key` identifiers of the `PropertyNode`\n                 */\n                if (FunctionTransformer.isProhibitedIdentifierOfShorthandPropertyNode(node)) {\n                    ignoredIdentifierNamesSet.add(node.key.name);\n\n                    return;\n                }\n\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                    && !ignoredIdentifierNamesSet.has(node.name)\n                ) {\n                    // should ignore identifiers of global function declarations\n                    if (this.isGlobalFunctionDeclarationIdentifier(node, parentNode)) {\n                        return;\n                    }\n\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        };\n\n        estraverse.replace(functionNode, visitor);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TImportSpecifier } from '../../types/node/TimportSpecifier';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     import foo from './foo';\n *     import * as bar from './bar';\n *\n * on:\n *     import _0x12d45f from './foo';\n *     import * as _0x12d45f from './bar';\n */\n@injectable()\nexport class ImportDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TImportSpecifier} importSpecifierNode\n     * @returns {boolean}\n     */\n    private static isProhibitedImportSpecifierNode (importSpecifierNode: TImportSpecifier): boolean {\n        return NodeGuards.isImportSpecifierNode(importSpecifierNode)\n            && importSpecifierNode.imported.name === importSpecifierNode.local.name;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isImportDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (importDeclarationNode: ESTree.ImportDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(importDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return importDeclarationNode;\n        }\n\n        this.storeImportSpecifierNames(importDeclarationNode, lexicalScopeNode);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return importDeclarationNode;\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeImportSpecifierNames (\n        importDeclarationNode: ESTree.ImportDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        importDeclarationNode.specifiers.forEach((importSpecifierNode: TImportSpecifier) => {\n            if (ImportDeclarationTransformer.isProhibitedImportSpecifierNode(importSpecifierNode)) {\n                return;\n            }\n\n            this.identifierObfuscatingReplacer.storeGlobalName(importSpecifierNode.local.name, lexicalScopeNode);\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] =\n            <ESTree.Identifier[]>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            if (replaceableIdentifier.name !== newReplaceableIdentifier.name) {\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n                NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n            }\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(labeledStatementNode);\n\n        if (!lexicalScopeNode) {\n            return labeledStatementNode;\n        }\n\n        this.storeLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n        this.replaceLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label.name, lexicalScopeNode);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !NodeMetadata.isReplacedLiteral(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (this.isProhibitedNode(literalNode, parentNode)) {\n            return literalNode;\n        }\n\n        let newLiteralNode: ESTree.Node;\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer\n                ).replace(literalNode.value);\n\n                break;\n\n            case 'number':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer\n                ).replace(literalNode.value);\n\n                break;\n\n            case 'string':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer\n                ).replace(literalNode.value);\n\n                break;\n\n            default:\n                newLiteralNode = literalNode;\n        }\n\n        NodeUtils.parentizeNode(newLiteralNode, parentNode);\n\n        return newLiteralNode;\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): boolean {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return true;\n        }\n\n        if (NodeGuards.isImportDeclarationNode(parentNode)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {number} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: number): ESTree.Node {\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(nodeValue)) {\n            rawValue = <string>this.numberLiteralCache.get(nodeValue);\n        } else {\n            if (!NumberUtils.isCeil(nodeValue)) {\n                rawValue = String(nodeValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${NumberUtils.toHex(nodeValue)}`;\n            }\n\n            this.numberLiteralCache.set(nodeValue, rawValue);\n        }\n\n        return NodeFactory.literalNode(nodeValue, rawValue);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStringArrayStorage } from '../../../../types/storages/TStringArrayStorage';\n\nimport { ICryptUtils } from '../../../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayIndexData } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IStringArrayIndexData';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeMetadata } from '../../../../node/NodeMetadata';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(\n            options\n        );\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n        this.randomGenerator = randomGenerator;\n        this.cryptUtils = cryptUtils;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringLiteralObfuscatingReplacer.rc4KeyLength\n                }),\n                StringLiteralObfuscatingReplacer.rc4KeysCount\n            );\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = NodeFactory.literalNode(hexadecimalIndex);\n\n        NodeMetadata.set(hexadecimalLiteralNode, { replacedLiteral: true });\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = NodeFactory.literalNode(literalValue);\n\n        NodeMetadata.set(rc4KeyLiteralNode, { replacedLiteral: true });\n\n        return rc4KeyLiteralNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: string): ESTree.Node {\n        const useStringArray: boolean = this.canUseStringArray(nodeValue);\n        const cacheKey: string = `${nodeValue}-${String(useStringArray)}`;\n        const useCacheValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCacheValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = useStringArray\n            ? this.replaceWithStringArrayCallNode(nodeValue)\n            : this.replaceWithLiteralNode(nodeValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {boolean}\n     */\n    private canUseStringArray (nodeValue: string): boolean {\n        return (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralObfuscatingReplacer.minimumLengthForStringArray &&\n            this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} stringArrayStorageLength\n     * @returns {IStringArrayIndexData}\n     */\n    private getStringArrayHexadecimalIndex (value: string, stringArrayStorageLength: number): IStringArrayIndexData {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return {\n                fromCache: true,\n                index: <string>this.stringLiteralHexadecimalIndexCache.get(value)\n            };\n        }\n\n        const hexadecimalRawIndex: string = NumberUtils.toHex(stringArrayStorageLength);\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${hexadecimalRawIndex}`;\n\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return {\n            fromCache: false,\n            index: hexadecimalIndex\n        };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let key: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                key = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (value: string): ESTree.Node {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const escapedValue: string = this.escapeSequenceEncoder.encode(encodedValue, this.options.unicodeEscapeSequence);\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const stringArrayStorageCallsWrapperName: string = this.stringArrayStorage.getStorageId().split('|')[1];\n\n        const { fromCache, index }: IStringArrayIndexData = this.getStringArrayHexadecimalIndex(\n            escapedValue,\n            stringArrayStorageLength\n        );\n\n        if (!fromCache) {\n            this.stringArrayStorage.set(stringArrayStorageLength, escapedValue);\n        }\n\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(index)\n        ];\n\n        if (key) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(key, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = NodeFactory.identifierNode(stringArrayStorageCallsWrapperName);\n\n        // prevent obfuscation of this identifier\n        NodeMetadata.set(stringArrayIdentifierNode, { renamedIdentifier: true });\n\n        return NodeFactory.callExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeBlockLexicalScopeUtils } from '../../node/NodeBlockLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<TNodeWithLexicalScope, boolean>}\n     */\n    private readonly lexicalScopesWithObjectPatternWithoutDeclarationMap: Map<TNodeWithLexicalScope, boolean> = new Map();\n\n    /**\n     * @type {TReplaceableIdentifiers}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isVariableDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = variableDeclarationNode.kind === 'var'\n            ? NodeLexicalScopeUtils.getLexicalScope(variableDeclarationNode)\n            : NodeBlockLexicalScopeUtils.getLexicalScope(variableDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return variableDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return variableDeclarationNode;\n        }\n\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? lexicalScopeNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(variableDeclarationNode, lexicalScopeNode, scopeNode);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, lexicalScopeNode);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeVariableNames (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        this.traverseDeclarationIdentifiers(\n            variableDeclarationNode,\n            (identifierNode: ESTree.Identifier) => {\n                if (\n                    this.isProhibitedVariableName(\n                        identifierNode,\n                        lexicalScopeNode,\n                        variableDeclarationNode\n                    )\n                ) {\n                    return;\n                }\n\n                if (isGlobalDeclaration) {\n                    this.identifierObfuscatingReplacer.storeGlobalName(identifierNode.name, lexicalScopeNode);\n                } else {\n                    this.identifierObfuscatingReplacer.storeLocalName(identifierNode.name, lexicalScopeNode);\n                }\n            }\n        );\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {VariableDeclaration} hostVariableDeclarationNode\n     * @returns {boolean}\n     */\n    private isProhibitedVariableName (\n        identifierNode: ESTree.Identifier,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        hostVariableDeclarationNode: ESTree.VariableDeclaration\n    ): boolean {\n        return this.isProhibitedVariableNameUsedInObjectPatternNode(\n            identifierNode,\n            lexicalScopeNode,\n            hostVariableDeclarationNode\n        );\n    }\n\n    /**\n     * Should not rename identifiers that used inside destructing assignment without declaration\n     *\n     * var a, b; // should not be renamed\n     * ({a, b} = {a: 1, b: 2});\n     *\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {VariableDeclaration} hostVariableDeclarationNode\n     * @returns {boolean}\n     */\n    private isProhibitedVariableNameUsedInObjectPatternNode (\n        identifierNode: ESTree.Identifier,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        hostVariableDeclarationNode: ESTree.VariableDeclaration\n    ): boolean {\n        // should transform variable declarations that cannot be reassigned\n        if (hostVariableDeclarationNode.kind === 'const') {\n            return false;\n        }\n\n        let isLexicalScopeHasObjectPatternWithoutDeclaration: boolean | undefined =\n            this.lexicalScopesWithObjectPatternWithoutDeclarationMap.get(lexicalScopeNode);\n\n        // lexical scope was traversed before and object pattern without declaration was not found\n        if (isLexicalScopeHasObjectPatternWithoutDeclaration === false) {\n            return false;\n        }\n\n        let isProhibitedVariableDeclaration: boolean = false;\n\n        estraverse.traverse(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void | estraverse.VisitorOption => {\n                if (\n                    NodeGuards.isObjectPatternNode(node)\n                    && parentNode\n                    && NodeGuards.isAssignmentExpressionNode(parentNode)\n                ) {\n                    isLexicalScopeHasObjectPatternWithoutDeclaration = true;\n\n                    const properties: ESTree.Property[] = node.properties;\n\n                    for (const property of properties) {\n                        if (property.computed || !property.shorthand) {\n                            continue;\n                        }\n\n                        if (!NodeGuards.isIdentifierNode(property.key)) {\n                            continue;\n                        }\n\n                        if (identifierNode.name !== property.key.name) {\n                            continue;\n                        }\n\n                        isProhibitedVariableDeclaration = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n                }\n            }\n        });\n\n        this.lexicalScopesWithObjectPatternWithoutDeclarationMap.set(\n            lexicalScopeNode,\n            isLexicalScopeHasObjectPatternWithoutDeclaration ?? false\n        );\n\n        return isProhibitedVariableDeclaration;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Node} scopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        scopeNode: ESTree.Node\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(scopeNode);\n\n        const identifierNames: string[] = [];\n\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            identifierNames.push(identifierNode.name);\n        });\n\n        identifierNames.forEach((identifierName: string) => {\n            const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined =\n                cachedReplaceableIdentifiersNamesMap.get(identifierName);\n\n            if (!cachedReplaceableIdentifiers) {\n                return;\n            }\n\n            const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n            for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n                const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n\n                if (identifierName !== replaceableIdentifier.name) {\n                    continue;\n                }\n\n                const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                    .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n                NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n            }\n        });\n    }\n\n    /**\n     * @param {Node} scopeNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (scopeNode: ESTree.Node, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(scopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {(identifier: Identifier) => void} callback\n     */\n    private traverseDeclarationIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        callback: (\n            identifier: ESTree.Identifier,\n            variableDeclarator: ESTree.VariableDeclarator\n        ) => void\n    ): void {\n        variableDeclarationNode.declarations\n            .forEach((variableDeclaratorNode: ESTree.VariableDeclarator) => {\n                estraverse.traverse(variableDeclaratorNode.id, {\n                    enter: (node: ESTree.Node) => {\n                        if (NodeGuards.isPropertyNode(node)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            callback(node, variableDeclaratorNode);\n                        }\n                    }\n                });\n            });\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeBlockLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithBlockLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n","import { TypeFromEnum } from '@gradecam/tsenum';\n\nimport { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayNotEmpty,\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator,\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: TypeFromEnum<typeof IdentifierNamesGenerator>;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    @ValidateIf((options: IOptions) =>\n        options.identifierNamesGenerator === IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator\n    )\n    @ArrayNotEmpty()\n    public readonly identifiersDictionary!: string[];\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly inputFileName!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedStrings!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {string | number}\n     */\n    public readonly seed!: string | number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: TypeFromEnum<typeof SourceMapMode>;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly splitStrings!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @ValidateIf((options: IOptions) => Boolean(options.splitStrings))\n    @Min(1)\n    public readonly splitStringsChunkLength!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.BrowserNoEval, ObfuscationTarget.Node])\n    public readonly target!: TypeFromEnum<typeof ObfuscationTarget>;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n","module.exports = require(\"class-validator\");","import { ValidationError } from 'class-validator';\n\nimport { TObject } from '../types/TObject';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} errors\n     * @returns {string}\n     */\n    public static format (errors: ValidationError[]): string {\n        return errors\n            .reduce(\n                (errorMessages: string[], error: ValidationError) => ([\n                    ...errorMessages,\n                    ValidationErrorsFormatter.formatWithNestedConstraints(error)\n                ]),\n                []\n            )\n            .join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} error\n     * @returns {string}\n     */\n    private static formatWithNestedConstraints (error: ValidationError): string {\n        const constraints: TObject<string> = error.constraints;\n\n        const rootError: string = `\\`${error.property}\\` errors:\\n`;\n        const nestedErrors: string = Object\n            .keys(constraints)\n            .map((constraint: string) => `    - ${constraints[constraint]}\\n`)\n            .join();\n\n        return `${rootError}${nestedErrors}`;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { InputFileNameRule } from './normalizer-rules/InputFileNameRule';\nimport { SeedRule } from './normalizer-rules/SeedRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { SplitStringsChunkLengthRule } from './normalizer-rules/SplitStringsChunkLengthRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        InputFileNameRule,\n        SeedRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        SplitStringsChunkLengthRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFrom(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringSeparator } from '../../enums/StringSeparator';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const InputFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { inputFileName } = options;\n\n    if (inputFileName) {\n        inputFileName = inputFileName\n            .replace(/^\\/+/, '')\n            .split(StringSeparator.Dot)\n            .slice(0, -1)\n            .join(StringSeparator.Dot) || inputFileName;\n\n        options = {\n            ...options,\n            inputFileName: `${inputFileName}.js`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SeedRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.seed) {\n        return {\n            ...options,\n            seed: options.seed\n        };\n    }\n\n    const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    return {\n        ...options,\n        seed: getRandomInteger(0, 999_999_999)\n    };\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringSeparator } from '../../enums/StringSeparator';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .replace(/(?:\\.js)?(?:\\.map)?$/, '');\n\n        let sourceMapFileNameParts: string[] = sourceMapFileName.split(StringSeparator.Dot);\n        const sourceMapFileNamePartsCount: number = sourceMapFileNameParts.length;\n        const lastPart: string = sourceMapFileNameParts[sourceMapFileNamePartsCount - 1];\n\n        // try to predict if last part is extension or not\n        if (sourceMapFileNamePartsCount > 1 && lastPart.length <= 3) {\n            sourceMapFileNameParts = sourceMapFileNameParts.slice(0, -1);\n        }\n\n        sourceMapFileName = sourceMapFileNameParts.join(StringSeparator.Dot);\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SplitStringsChunkLengthRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.splitStringsChunkLength === 0) {\n        options = {\n            ...options,\n            splitStrings: false,\n            splitStringsChunkLength: 0\n        };\n    } else {\n        options = {\n            ...options,\n            splitStringsChunkLength: Math.floor(options.splitStringsChunkLength)\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvalCallExpressionTransformer';\nimport { MetadataTransformer } from '../../../node-transformers/preparing-transformers/MetadataTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\nimport { ReservedStringObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ReservedStringObfuscatingGuard';\nimport { VariablePreserveTransformer } from \"../../../node-transformers/preparing-transformers/VariablePreserveTransformer\";\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MetadataTransformer)\n        .whenTargetNamed(NodeTransformer.MetadataTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListObfuscatingGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentObfuscatingGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ReservedStringObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ReservedStringObfuscatingGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariablePreserveTransformer)\n        .whenTargetNamed(NodeTransformer.VariablePreserveTransformer);\n});\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport * as estraverse from \"estraverse\";\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { ConditionalCommentObfuscatingGuard } from \"./obfuscating-guards/ConditionalCommentObfuscatingGuard\";\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = [\n        '@license',\n        '@preserve'\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Initializing:\n                return {\n                    leave: (node: ESTree.Node) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            return this.transformNode(node);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     * Move comments to their nodes\n     *\n     * @param {Node} rootNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (rootNode: ESTree.Program): ESTree.Node {\n        if (!rootNode.comments || !rootNode.comments.length) {\n            return rootNode;\n        }\n\n        const comments: ESTree.Comment[] = this.transformComments(rootNode.comments);\n\n        if (comments.length === 0) {\n            return rootNode;\n        }\n\n        if (!rootNode.body.length) {\n            rootNode.leadingComments = comments;\n\n            return rootNode;\n        }\n\n        estraverse.traverse(rootNode, {\n            enter: (node: ESTree.Node): void => {\n                if (node === rootNode) {\n                    return;\n                }\n\n                const commentIdx: number = comments.findIndex((comment: ESTree.Comment) =>\n                    comment.range && node.range && comment.range[0] < node.range[0]\n                );\n\n                if (commentIdx === -1) {\n                    return;\n                }\n\n                node.leadingComments = comments.splice(commentIdx, comments.length - commentIdx).reverse();\n            }\n        });\n\n        if (comments.length > 0) {\n            rootNode.trailingComments = comments.reverse();\n        }\n\n        return rootNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((preservedWord: string) => comment.value.includes(preservedWord)) ||\n            ConditionalCommentObfuscatingGuard.isConditionalComment(comment)\n        ).reverse();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeGroupStorage } from '../../types/storages/TCustomNodeGroupStorage';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphAnalyzer';\nimport { ICallsGraphData } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeGroupStorage}\n     */\n    private readonly customNodeGroupStorage: TCustomNodeGroupStorage;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {ICallsGraphAnalyzer}\n     */\n    private readonly callsGraphAnalyzer: ICallsGraphAnalyzer;\n\n    /**\n     * @type {ICallsGraphData[]}\n     */\n    private callsGraphData: ICallsGraphData[] = [];\n\n    /**\n     * @type {IPrevailingKindOfVariablesAnalyzer}\n     */\n    private readonly prevailingKindOfVariablesAnalyzer: IPrevailingKindOfVariablesAnalyzer;\n\n    /**\n     * @param {ICallsGraphAnalyzer} callsGraphAnalyzer\n     * @param {IPrevailingKindOfVariablesAnalyzer} prevailingKindOfVariablesAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {TCustomNodeGroupStorage} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ICallsGraphAnalyzer) callsGraphAnalyzer: ICallsGraphAnalyzer,\n        @inject(ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)\n            prevailingKindOfVariablesAnalyzer: IPrevailingKindOfVariablesAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: TCustomNodeGroupStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.callsGraphAnalyzer = callsGraphAnalyzer;\n        this.prevailingKindOfVariablesAnalyzer = prevailingKindOfVariablesAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.callsGraphData = this.callsGraphAnalyzer.analyze(node);\n        this.prevailingKindOfVariablesAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.callsGraphData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.callsGraphData);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: ESTree.Statement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], NodeFactory.blockStatementNode(ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return NodeFactory.callExpressionNode(\n            NodeFactory.identifierNode('eval'),\n            [\n                NodeFactory.literalNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n","module.exports = require(\"js-string-escape\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds metadata properties to each node\n */\n@injectable()\nexport class MetadataTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        NodeMetadata.set(node, { ignoredNode: false });\n\n        if (NodeGuards.isIdentifierNode(node)) {\n            NodeMetadata.set(node, { renamedIdentifier: false });\n        }\n\n        if (NodeGuards.isLiteralNode(node)) {\n            NodeMetadata.set(node, { replacedLiteral: false });\n        }\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListObfuscatingGuard,\n        ObfuscatingGuard.ConditionalCommentObfuscatingGuard,\n        ObfuscatingGuard.ReservedStringObfuscatingGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        NodeMetadata.set(node, {\n            ignoredNode: !obfuscationAllowed\n        });\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n","import { inject, injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ReservedStringObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (\n            this.options.reservedStrings.length\n            && NodeGuards.isLiteralNode(node)\n            && typeof node.value === 'string'\n        ) {\n            return !this.isReservedString(node.value);\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {string} value\n     * @returns {boolean}\n     */\n    private isReservedString (value: string): boolean {\n        return this.options.reservedStrings\n            .some((reservedString: string) => {\n                return new RegExp(reservedString, 'g').exec(value) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\n\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Preserve non-replaceable variables\n */\n@injectable()\nexport class VariablePreserveTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            NodeGuards.isIdentifierNode(node)\n                            && parentNode\n                            && (\n                                NodeGuards.parentNodeIsPropertyNode(node, parentNode)\n                                || NodeGuards.parentNodeIsMemberExpressionNode(node, parentNode)\n                                || NodeGuards.parentNodeIsMethodDefinitionNode(node, parentNode)\n                                || NodeGuards.isLabelIdentifierNode(node, parentNode)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Identifier} node\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Identifier, parentNode: ESTree.Node): ESTree.Node {\n        this.identifierObfuscatingReplacer.preserveName(node.name);\n\n        return node;\n    }\n\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <string, ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <string, ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ArrayStorage } from '../ArrayStorage';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n        const stringArrayName: string = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        const stringArrayCallsWrapperName: string = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.storageId = `${stringArrayName}|${stringArrayCallsWrapperName}`;\n    }\n\n    /**\n     * @param {number} rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = this.arrayUtils.rotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayStorage } from '../interfaces/storages/IArrayStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class ArrayStorage <V> implements IArrayStorage <V> {\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {V[]}\n     */\n    @initializable()\n    protected storage!: V[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = [];\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {number} key\n     * @returns {V}\n     */\n    public get (key: number): V {\n        const value: V | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {number}\n     */\n    public getKeyOf (value: V): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {V[]}\n     */\n    public getStorage (): V[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {number} key\n     * @param {V} value\n     */\n    public set (key: number, value: V): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { ILevelledTopologicalSorter } from '../../../interfaces/utils/ILevelledTopologicalSorter';\nimport { INodeTransformerNamesGroupsBuilder } from '../../../interfaces/utils/INodeTransformerNamesGroupsBuilder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { LevelledTopologicalSorter } from '../../../utils/LevelledTopologicalSorter';\nimport { NodeTransformerNamesGroupsBuilder } from '../../../utils/NodeTransformerNamesGroupsBuilder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n\n    // levelled topological sorter\n    bind<ILevelledTopologicalSorter>(ServiceIdentifiers.ILevelledTopologicalSorter)\n        .to(LevelledTopologicalSorter);\n\n    // node transformer names groups builder\n    bind<INodeTransformerNamesGroupsBuilder>(ServiceIdentifiers.INodeTransformerNamesGroupsBuilder)\n        .to(NodeTransformerNamesGroupsBuilder)\n        .inSingletonScope();\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public createWithRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T | null}\n     */\n    public findMostOccurringElement <T extends string | number> (array: T[]): T | null {\n        const arrayLength: number = array.length;\n\n        if (!arrayLength) {\n            return null;\n        }\n\n        const elementsMap: Partial<{[key in T]: number}> = {};\n\n        let mostOccurringElement: T = array[0];\n        let mostOccurringElementCount: number = 1;\n\n        for (const element of array) {\n            const currentElementCount: number = elementsMap[element] ?? 0;\n            const updatedElementCount: number = currentElementCount + 1;\n\n            if (updatedElementCount > mostOccurringElementCount) {\n                mostOccurringElement = element;\n                mostOccurringElementCount = updatedElementCount;\n            }\n\n            elementsMap[element] = updatedElementCount;\n        }\n\n        return mostOccurringElement;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public rotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop();\n\n            if (temp) {\n                newArray.unshift(temp);\n            }\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public shuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    // tslint:disable\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    // tslint:enable\n\n    /**\n     * Hides string inside a other random string with larger length\n     *\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            ''\n        );\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    // tslint:disable\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    // tslint:enable\n}\n","module.exports = require(\"md5\");","module.exports = require(\"chance\");","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { ILevelledTopologicalSorter } from '../interfaces/utils/ILevelledTopologicalSorter';\n\ntype TVisitMark = 'ok' | 'visiting';\n\ninterface IVisitMarks <TValue extends string> {\n    [key: string]: TVisitMark;\n}\n\n/**\n * Port and rework of https://github.com/loveencounterflow/ltsort\n */\n@injectable()\nexport class LevelledTopologicalSorter <TValue extends string = string> implements ILevelledTopologicalSorter<TValue> {\n    /**\n     * @type {Map<TValue, TValue[]}\n     */\n    private readonly graph: Map<TValue, TValue[]> = new Map();\n\n    /**\n     * @param {TValue} precedent\n     * @param {TValue | null} consequent\n     * @returns {this}\n     */\n    public add (\n        precedent: TValue,\n        consequent: TValue | null = null\n    ): this {\n        if (consequent !== null) {\n            return this.link(precedent, consequent);\n        }\n\n        return this.register(precedent);\n    }\n\n    /**\n     * As given in http://en.wikipedia.org/wiki/Topological_sorting\n     *\n     * @returns {TValue[]}\n     */\n    public sort (): TValue[] {\n        const consequents: TValue[] = Array.from(this.graph.keys());\n\n        const results: TValue[] = [];\n        const marks: IVisitMarks<TValue> = {};\n\n        for (const consequent of consequents) {\n            if (marks[consequent] !== undefined) {\n                continue;\n            }\n\n            this.visit(results, marks, consequent);\n        }\n\n        return results;\n    }\n\n    /**\n     * @returns {TValue[][]}\n     */\n    public sortByGroups (): TValue[][] {\n        this.sort();\n\n        const resultItemsGroups: TValue[][] = [];\n\n        while (this.hasNodes()) {\n            const rootNodes: TValue[] = this.findRootNodes();\n\n            resultItemsGroups.push(rootNodes);\n\n            for (const rootNode of rootNodes) {\n                this.delete(rootNode);\n            }\n        }\n\n        return resultItemsGroups;\n    }\n\n    /**\n     * @param {TValue} consequent\n     */\n    private delete (consequent: TValue): void {\n        const precedents: TValue[] = this.getPrecedents(consequent);\n\n        if (precedents.length) {\n            throw new Error(`Unable to remove non-root node: ${consequent}`);\n        }\n\n        this.graph.delete(consequent);\n\n        const precedentsGroups: string[][] = Array.from(this.graph.values());\n\n        for (const precedentsGroup of precedentsGroups) {\n            const precedentsCount: number = precedentsGroup.length - 1;\n\n            for (let index: number = precedentsCount; index >= 0; index = index - 1) {\n                if (precedentsGroup[index] !== consequent) {\n                    continue;\n                }\n\n                precedentsGroup.splice(index, 1);\n            }\n        }\n    }\n\n    /**\n     * @returns {TValue[]}\n     */\n    private findRootNodes (): TValue[] {\n        const consequents: TValue[] = Array.from(this.graph.keys());\n        const rootNodes: TValue[] = [];\n\n        for (const consequent of consequents) {\n            if (!this.hasPrecedents(consequent)) {\n                rootNodes.push(consequent);\n            }\n        }\n\n        return rootNodes;\n    }\n\n    /**\n     * @param {TValue} consequent\n     * @returns {TValue[]}\n     */\n    private getPrecedents (consequent: TValue): TValue[] {\n        const precedents: TValue[] | undefined = this.graph.get(consequent);\n\n        if (!precedents) {\n            throw new Error(`Unknown node: ${consequent}`);\n        }\n\n        return precedents;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    private hasNodes (): boolean {\n        return this.graph.size > 0;\n    }\n\n    /**\n     * @param {TValue} consequent\n     * @returns {boolean}\n     */\n    private hasPrecedents (consequent: TValue): boolean {\n        return this.getPrecedents(consequent).length > 0;\n    }\n\n    /**\n     * @param {TValue} precedent\n     * @param {TValue} consequent\n     * @returns {this}\n     */\n    private link (precedent: TValue, consequent: TValue): this {\n        this.register(precedent);\n        this.register(consequent);\n\n        const target: TValue[] | undefined = this.graph.get(consequent);\n\n        if (target && !target.includes(precedent)) {\n            target.push(precedent);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {TValue} name\n     * @returns {this}\n     */\n    private register (name: TValue): this {\n        if (!this.graph.has(name)) {\n            this.graph.set(name, []);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {TValue[]} results\n     * @param {IVisitMarks<TValue>} marks\n     * @param {TValue} name\n     * @returns {null}\n     */\n    private visit (\n        results: TValue[],\n        marks: IVisitMarks<TValue>,\n        name: TValue\n    ): void {\n        const mark: TVisitMark = marks[name];\n\n        if (mark === 'visiting') {\n            throw new Error(`Detected cycle involving node: ${name}`);\n        }\n\n        if (mark) {\n            return;\n        }\n\n        marks[name] = 'visiting';\n\n        const precedents: TValue[] = this.getPrecedents(name);\n\n        for (const precedent of precedents) {\n            this.visit(results, marks, precedent);\n        }\n\n        marks[name] = 'ok';\n        results.push(name);\n\n        return;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TNodeTransformersRelationEdge } from '../types/node-transformers/TNodeTransformersRelationEdge';\nimport { TNormalizedNodeTransformers } from '../types/node-transformers/TNormalizedNodeTransformers';\n\nimport { ILevelledTopologicalSorter } from '../interfaces/utils/ILevelledTopologicalSorter';\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { INodeTransformerNamesGroupsBuilder } from '../interfaces/utils/INodeTransformerNamesGroupsBuilder';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\n\n@injectable()\nexport class NodeTransformerNamesGroupsBuilder implements INodeTransformerNamesGroupsBuilder {\n    /**\n     * @type {ILevelledTopologicalSorter<NodeTransformer>}\n     */\n    private readonly levelledTopologicalSorter: ILevelledTopologicalSorter<NodeTransformer>;\n\n    constructor (\n        @inject(ServiceIdentifiers.ILevelledTopologicalSorter)\n            levelledTopologicalSorter: ILevelledTopologicalSorter<NodeTransformer>\n    ) {\n        this.levelledTopologicalSorter = levelledTopologicalSorter;\n    }\n\n    /**\n     * Builds sorted NodeTransformer names by topological sort with levels\n     *\n     * For example, if SplitString transformer has following dependencies inside `runAfter` property:\n     *  - NodeTransformer.ObjectExpressionKeysTransformer,\n     *  - NodeTransformer.TemplateLiteralTransformer\n     *\n     *  Than result node transformer names groups will be like:\n     *  [\n     *      [\n     *          SomeTransformerA,\n     *          ObjectExpressionKeysTransformer,\n     *          TemplateLiteralTransformer,\n     *          SomeTransformerB\n     *      ],\n     *      [\n     *          SplitStringTransformer\n     *      ]\n     *  ]\n     *\n     * @param {TNormalizedNodeTransformers} normalizedNodeTransformers\n     * @returns {NodeTransformer[][]}\n     */\n    public build (normalizedNodeTransformers: TNormalizedNodeTransformers): NodeTransformer[][] {\n        const nodeTransformerNames: NodeTransformer[] = <NodeTransformer[]>Object.keys(normalizedNodeTransformers);\n        const relationEdges: TNodeTransformersRelationEdge[] = this.buildNodeTransformersRelationEdges(\n            nodeTransformerNames,\n            normalizedNodeTransformers\n        );\n\n        for (const [precedent, consequent] of relationEdges) {\n            this.levelledTopologicalSorter.add(precedent, consequent);\n        }\n\n        return this.levelledTopologicalSorter.sortByGroups();\n    }\n\n    /**\n     * @param {NodeTransformer[]} nodeTransformerNames\n     * @param {TNormalizedNodeTransformers} normalizedNodeTransformers\n     * @returns {[NodeTransformer, NodeTransformer][]}\n     */\n    private buildNodeTransformersRelationEdges (\n        nodeTransformerNames: NodeTransformer[],\n        normalizedNodeTransformers: TNormalizedNodeTransformers\n    ): TNodeTransformersRelationEdge[] {\n        const relationEdges: TNodeTransformersRelationEdge[] = [];\n\n        for (const nodeTransformerName of nodeTransformerNames) {\n            const nodeTransformer: INodeTransformer = normalizedNodeTransformers[nodeTransformerName];\n            const runAfterRelations: NodeTransformer[] | undefined = nodeTransformer.runAfter;\n\n            if (!runAfterRelations || !runAfterRelations.length) {\n                relationEdges.push([nodeTransformerName, null]);\n                continue;\n            }\n\n            for (const runAfterRelation of runAfterRelations) {\n                const isUnknownRelation: boolean = !normalizedNodeTransformers[runAfterRelation];\n\n                if (isUnknownRelation) {\n                    relationEdges.push([nodeTransformerName, null]);\n                    continue;\n                }\n\n                relationEdges.push([runAfterRelation, nodeTransformerName]);\n            }\n        }\n\n        return relationEdges;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen';\nimport * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport { TObfuscatedCodeFactory } from './types/container/source-code/TObfuscatedCodeFactory';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { EspreeFacade } from './EspreeFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {Options}\n     */\n    private static readonly espreeParseOptions: espree.ParseOptions = {\n        comment: true,\n        ecmaVersion: 10,\n        loc: true,\n        range: true\n    };\n\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.ImportDeclarationTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MetadataTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.SplitStringTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariableDeclarationTransformer,\n        NodeTransformer.VariablePreserveTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {TObfuscatedCodeFactory}\n     */\n    private readonly obfuscatedCodeFactory: TObfuscatedCodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {TObfuscatedCodeFactory} obfuscatedCodeFactory\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.Factory__IObfuscatedCode) obfuscatedCodeFactory: TObfuscatedCodeFactory,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.randomGenerator = randomGenerator;\n        this.obfuscatedCodeFactory = obfuscatedCodeFactory;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscatedCode}\n     */\n    public obfuscate (sourceCode: string): IObfuscatedCode {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, process.env.VERSION);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getInputSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscatedCode(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return EspreeFacade.parse(sourceCode, JavaScriptObfuscator.espreeParseOptions);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        astTree = this.runTransformationStage(astTree, TransformationStage.Initializing);\n\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments\n            && !astTree.trailingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = this.options.inputFileName || 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscatedCode}\n     */\n    private getObfuscatedCode (generatorOutput: IGeneratorOutput): IObfuscatedCode {\n        return this.obfuscatedCodeFactory(generatorOutput.code, generatorOutput.map);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n","import * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over `espree`\n */\nexport class EspreeFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 15;\n\n    /**\n     * @type {SourceType[]}\n     */\n    private static readonly sourceTypes: espree.SourceType[] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @param {string} input\n     * @param {Options} config\n     * @returns {Program}\n     */\n    public static parse (input: string, config: espree.ParseOptions): ESTree.Program | never {\n        const sourceTypeLength: number = EspreeFacade.sourceTypes.length;\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                return EspreeFacade.parseType(input, config, EspreeFacade.sourceTypes[i]);\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(EspreeFacade.processParsingError(\n                    input,\n                    error.message,\n                    {\n                        line: error.lineNumber,\n                        column: error.column,\n                    }\n                ));\n            }\n        }\n\n        throw new Error(`Espree parsing error`);\n    }\n\n    /**\n     * @param {string} input\n     * @param {ParseOptions} inputConfig\n     * @param {SourceType} sourceType\n     * @returns {Program}\n     */\n    private static parseType (\n        input: string,\n        inputConfig: espree.ParseOptions,\n        sourceType: espree.SourceType\n    ): ESTree.Program {\n        const config: espree.ParseOptions = { ...inputConfig, sourceType };\n\n        return espree.parse(input, config);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {Position} position\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, position: ESTree.Position | null): never {\n        if (!position || !position.line || !position.column) {\n            throw new Error(errorMessage);\n        }\n\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[position.line - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, position.column - EspreeFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, position.column + EspreeFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = EspreeFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`Line ${position.line}: ${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n","import { decorate, injectable } from 'inversify';\nimport EventEmitter from 'eventemitter3';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n","module.exports = require(\"eventemitter3\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { IOptions } from '../interfaces/options/IOptions';\n\n@injectable()\nexport class ObfuscatedCode implements IObfuscatedCode {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    constructor (\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.correctObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    private correctObfuscatedCode (): string {\n        if (!this.sourceMap) {\n            return this.obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(this.sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return this.obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n        }\n\n        return `${this.obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n","import { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @type {string}\n     */\n    private readonly sourceMap: string;\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     */\n    constructor (sourceCode: string, sourceMap: string) {\n        this.sourceCode = sourceCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.sourceCode;\n    }\n}\n","import { inject, injectable } from 'inversify';\n\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TNormalizedNodeTransformers } from '../types/node-transformers/TNormalizedNodeTransformers';\nimport { TTransformersRunnerData } from '../types/node-transformers/TTransformersRunnerData';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { INodeTransformerNamesGroupsBuilder } from '../interfaces/utils/INodeTransformerNamesGroupsBuilder';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\nimport { NodeMetadata } from '../node/NodeMetadata';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {Map<NodeTransformer[], TTransformersRunnerData>}\n     */\n    private readonly cachedNodeTransformersData: Map<NodeTransformer[], TTransformersRunnerData> = new Map();\n\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @type {INodeTransformerNamesGroupsBuilder}\n     */\n    private readonly nodeTransformerNamesGroupsBuilder: INodeTransformerNamesGroupsBuilder;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     * @param {INodeTransformerNamesGroupsBuilder} nodeTransformerNamesGroupsBuilder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer)\n            nodeTransformerFactory: TNodeTransformerFactory,\n        @inject(ServiceIdentifiers.INodeTransformerNamesGroupsBuilder)\n            nodeTransformerNamesGroupsBuilder: INodeTransformerNamesGroupsBuilder,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n        this.nodeTransformerNamesGroupsBuilder = nodeTransformerNamesGroupsBuilder;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformerNames\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformerNames: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformerNames.length) {\n            return astTree;\n        }\n\n        let normalizedNodeTransformers: TNormalizedNodeTransformers;\n        let nodeTransformerNamesGroups: NodeTransformer[][];\n\n        if (!this.cachedNodeTransformersData.has(nodeTransformerNames)) {\n            normalizedNodeTransformers = this.buildNormalizedNodeTransformers(nodeTransformerNames);\n            nodeTransformerNamesGroups = this.nodeTransformerNamesGroupsBuilder.build(normalizedNodeTransformers);\n            this.cachedNodeTransformersData.set(nodeTransformerNames, [normalizedNodeTransformers, nodeTransformerNamesGroups]);\n        } else {\n            [\n                normalizedNodeTransformers,\n                nodeTransformerNamesGroups\n            ] = <TTransformersRunnerData>this.cachedNodeTransformersData.get(nodeTransformerNames);\n        }\n\n        for (const nodeTransformerNamesGroup of nodeTransformerNamesGroups) {\n            const enterVisitors: IVisitor[] = [];\n            const leaveVisitors: IVisitor[] = [];\n\n            for (const nodeTransformerName of nodeTransformerNamesGroup) {\n                const nodeTransformer: INodeTransformer = normalizedNodeTransformers[nodeTransformerName];\n                const visitor: IVisitor | null = nodeTransformer.getVisitor(transformationStage);\n\n                if (!visitor) {\n                    continue;\n                }\n\n                if (visitor.enter) {\n                    enterVisitors.push({ enter: visitor.enter });\n                }\n\n                if (visitor.leave) {\n                    leaveVisitors.push({ leave: visitor.leave });\n                }\n            }\n\n            if (!enterVisitors.length && !leaveVisitors.length) {\n                continue;\n            }\n\n            estraverse.replace(astTree, {\n                enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n                leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n            });\n        }\n\n        return astTree;\n    }\n\n    /**\n     * @param {NodeTransformer[]} nodeTransformerNames\n     * @returns {TNormalizedNodeTransformers}\n     */\n    private buildNormalizedNodeTransformers (nodeTransformerNames: NodeTransformer[]): TNormalizedNodeTransformers {\n        return nodeTransformerNames\n            .reduce<TNormalizedNodeTransformers>(\n                (acc: TNormalizedNodeTransformers, nodeTransformerName: NodeTransformer) => ({\n                    ...acc,\n                    [nodeTransformerName]: this.nodeTransformerFactory(nodeTransformerName)\n                }),\n                {}\n            );\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (NodeMetadata.isIgnoredNode(node)) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n","\"use strict\";\n\nimport { JavaScriptObfuscator } from './src/JavaScriptObfuscatorFacade';\n\nmodule.exports = JavaScriptObfuscator;\n"],"sourceRoot":""}